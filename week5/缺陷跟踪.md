# 缺陷跟踪

## 首部

### attributes

- **项目名称**: Go语言书城项目
- **项目标识**: GOBOOKSTORE-2025-001
- **版本**: V1.0
### 状态与版本信息
- **文件状态**: 正式报告
- **文件标识**: SC-GOBOOKSTORE-V1.0-DRAFT
- **当前版本**: V1.0

- **作者**:

  - **姓名**: 白雨轩
  
  - **学号**: 2022011150
  
  - **姓名**: 牛岳峰
  
  - **学号**: 2022011155
  
  - **姓名**: 殷科鹏
  
  - **学号**: 2022010263
  
  - **团队**: 404回收站

- **完成日期**: 2025年10月19

- **版本更新信息**: 首次创建

# 缺陷跟踪

## 问题编号：BUG-001

### 问题描述
在图书管理模块的并发测试中，发现当多个用户同时更新同一本图书的价格时，偶尔会出现最终价格与预期不符的情况。这一现象违背了测试最佳实践中对于并发操作稳定性的要求，也与测试覆盖的功能点里并发处理需验证系统稳定性的目标相冲突。

经过多次模拟10用户同时更新的场景，发现约有15%的概率出现数据不一致，比如预期将价格从50元更新为60元，最终却显示为55元等中间值。

进一步测试发现：
- 该问题在高并发场景下（如20个及以上并发线程）出现概率会提升至30%左右
- 不仅限于价格字段，库存数量在并发更新时也存在类似的数据错乱问题
- 数据不一致的情况在不同网络环境下均能复现，与网络延迟无关

### 测试结果
执行 `go test -v ./dao -run TestBookConcurrentOperations` 后，测试结果如下：
- 在100次并发更新测试中，15次出现数据不一致
- 测试报告显示“--- FAIL: TestBookConcurrentOperations (1.23s)”
- 失败原因均为“最终价格与预期不符”

详细日志分析：
- 失败案例中存在多次更新操作未读取到最新数据的情况
- 典型场景：线程A读取价格为50元并准备更新为60元时，线程B同时读取到50元并更新为60元，最终仅一次更新生效
- 数据库操作日志显示，多次更新请求的执行顺序存在交叉，未按预期的原子操作执行

### 关联测试点
- 对应《BOOK_TEST_SUMMARY.md》中“并发处理 - 系统稳定性验证”功能点
- 违反《TESTING_GUIDE.md》“并发测试需避免竞态条件”要求
- 影响图书管理模块的核心数据一致性，与“测试覆盖的功能点”中：
  - “并发添加图书”稳定性要求相冲突
  - “并发查询图书”稳定性要求相冲突

### 发现日期
2024-06-10

### 紧急程度
高

### 解决措施
需要为图书价格更新操作添加合适的事务控制和锁机制，确保在并发场景下，每次更新操作都能基于最新的图书数据进行，避免因多线程同时读写导致的数据错乱。具体措施包括：

1. 数据库层优化：
   - 采用数据库行级锁，在执行更新语句时锁定对应的图书记录
   - 使用`SELECT ... FOR UPDATE`语句在事务中获取行锁
   - 确保事务的ACID特性，待当前更新完成后再释放锁

2. 应用层补充：
   - 实现乐观锁机制作为补充，通过版本号字段控制更新
   - 当检测到版本号不匹配时，提示用户重新操作
   - 增加重试机制，处理并发冲突场景

3. 测试用例优化：
   - 增加对库存等其他字段的并发更新验证
   - 扩展测试场景至不同并发用户数（5/10/20/50用户）
   - 增加长时间运行的稳定性测试（持续1小时的并发更新）

### 责任人
殷科鹏

### 期限
2024-06-15

### 状态
处理中

### 复现步骤
1. 初始化图书信息：
   - 价格为50元
   - 库存为100本
   - 版本号为1

2. 编写并发测试脚本：
   ```go
   func updatePrice(bookID int, expectedPrice float64, wg *sync.WaitGroup) {
       defer wg.Done()
       book, err := dao.GetBookByID(bookID)
       if err != nil {
           log.Printf("获取图书失败: %v", err)
           return
       }
       book.Price = expectedPrice
       err = dao.UpdateBook(book)
       if err != nil {
           log.Printf("更新图书失败: %v", err)
       }
   }
   ```

3. 启动10个并发线程，所有线程均将价格更新为60元

4. 等待所有线程执行完成后，查询图书最终价格

5. 验证价格是否为预期的60元

6. 重复执行上述步骤100次，统计数据不一致的次数

## 问题编号：BUG-002

### 问题描述
在测试图书管理模块的分页功能时，当分页参数pageNo为0或负数时，系统未进行有效处理，而是直接返回了第一页的数据，这不符合测试最佳实践中错误处理需测试边界条件的要求。

例如，当请求“/getPageBooks?pageNo=-1”时，本应返回错误提示或默认调整为有效页码，但实际返回结果与pageNo=1时一致，可能导致用户在错误输入时获得不符合预期的内容，影响使用体验。

进一步测试发现：
- 当pageNo为极大值（如1000000）时，系统会返回空数据但未给出任何提示信息
- 用户无法区分是确实没有数据还是参数错误
- 非数字类型的pageNo参数（如"abc"、"12a"）会导致系统返回500错误，而非友好的参数错误提示

### 测试结果
在`TestBookControllerOperations`的“测试获取分页图书”子测试中：

1. 基础测试结果：
   - 输入pageNo=0、-1、-5等参数时，返回数据与pageNo=1完全一致
   - 测试用例因“边界参数未按预期处理”失败

2. 补充测试结果：
   - 当pageNo为1000000时，接口返回状态码200，body中包含空的图书列表
   - 无任何错误提示字段，与预期的“参数超出有效范围”提示不符
   - 输入"abc"作为pageNo时，系统返回500 Internal Server Error

3. 日志分析：
   - 分页处理逻辑中未对pageNo进行最小值和最大值校验
   - 直接将参数转换为整数后传入数据库查询
   - 未处理字符串转整数的异常情况，导致panic并返回500错误

### 关联测试点
- 对应《BOOK_TEST_SUMMARY.md》“分页和筛选功能 - 分页参数验证”功能点
- 违反“错误处理需测试边界条件”最佳实践
- 同时影响以下测试场景：
  - “HTTP获取分页图书”
  - “HTTP价格筛选”
- 与《TESTING_GUIDE.md》中“测试场景需覆盖异常参数处理”的要求相冲突

### 发现日期
2024-06-11

### 紧急程度
中

### 解决措施
在分页参数处理逻辑中添加全面的校验机制，具体如下：

1. 参数校验逻辑实现：
   ```go
   func GetPageBooks(w http.ResponseWriter, r *http.Request) {
       pageNoStr := r.URL.Query().Get("pageNo")
       // 默认为第一页
       pageNo := 1
       
       // 尝试转换参数
       parsedPageNo, err := strconv.Atoi(pageNoStr)
       if err != nil {
           // 记录异常参数日志
           log.Printf("无效的pageNo参数: %s，错误: %v", pageNoStr, err)
           // 返回400错误
           w.WriteHeader(http.StatusBadRequest)
           json.NewEncoder(w).Encode(map[string]string{
               "error": "无效的页码参数，请输入正整数",
           })
           return
       }
       
       // 校验最小值
       if parsedPageNo < 1 {
           log.Printf("pageNo参数小于1: %d，自动调整为1", parsedPageNo)
           pageNo = 1
           w.Header().Set("X-Warning", "页码不能小于1，已自动调整为1")
       } else {
           pageNo = parsedPageNo
       }
       
       // 计算总页数，校验最大值
       totalBooks := dao.GetTotalBookCount()
       pageSize := 10 // 假设每页10条数据
       maxPageNo := (totalBooks + pageSize - 1) / pageSize
       
       if pageNo > maxPageNo && maxPageNo > 0 {
           log.Printf("pageNo参数超过最大值: %d > %d，自动调整为%d", 
                      pageNo, maxPageNo, maxPageNo)
           pageNo = maxPageNo
           w.Header().Set("X-Warning", 
                         fmt.Sprintf("页码超过最大值%d，已自动调整为最后一页", maxPageNo))
       }
       
       // 后续分页查询逻辑...
       books, err := dao.GetPageBooks(pageNo, pageSize)
       // ...
   }
   ```

2. 前端配合处理：
   - 接收并显示响应头中的警告信息
   - 在页码输入框添加前端验证，限制输入范围

3. 测试用例完善：
   - 增加对pageNo为0、负数、极大值的测试
   - 增加对非数字类型参数的测试
   - 验证警告信息和错误提示的正确性

### 责任人
聂子博

### 期限
2024-06-16

### 状态
处理中

### 影响范围
- 直接影响：
  - 图书列表分页展示功能
  - 依赖分页参数的价格筛选模块
  
- 间接影响：
  - 首页图书列表
  - 分类图书列表
  - 搜索结果分页展示
  
- 业务影响：
  - 用户在输入异常页码时获得误导性结果
  - 影响用户对系统的信任度
  - 增加前端异常处理的复杂度
  - 可能导致用户重复提交无效请求，增加服务器负担

## 问题编号：BUG-003

### 问题描述
在Controller层测试的图书数据验证中，发现当输入负价格的图书信息时，系统虽然在测试用例中有相关验证场景，但实际处理时并未有效拦截，而是允许负价格图书被添加到系统中。

这与测试覆盖的功能点里数据验证需处理异常数据的要求不符，可能导致后续订单计算、库存管理等环节出现错误，比如计算订单总价时出现负数，影响业务逻辑的正确性。

进一步测试发现：
- 不仅是直接添加负价格图书会出现该问题，在更新已有图书价格时，若将价格修改为负数，系统同样会接受并保存
- 没有任何提示信息告知用户价格输入异常
- 该问题在多种操作路径下均能复现：
  - 通过后台管理系统的表单提交
  - API接口直接调用
  - 批量导入图书数据时

这说明数据验证逻辑在多个入口点都存在疏漏。

此外，当负价格图书存在于系统中时：
- 在前端展示列表中，价格会以负数形式显示
- 不仅影响用户体验，还可能让用户产生误解，以为该图书有特殊优惠或系统出现故障

从业务角度来看：
- 负价格的图书在实际销售场景中是不合理的
- 可能导致订单金额计算错误，例如用户购买多本负价格图书后，订单总价可能为负数
- 在财务结算时会造成严重问题，影响账目准确性
- 库存管理模块在处理负价格图书的销售记录时，也可能因价格异常而出现数据统计偏差
- 给库存盘点和销售分析带来困扰

### 测试结果
在`TestBookControllerDataValidation`测试中：

1. 基础测试结果：
   - 输入价格为-20、-50等负值时，接口返回状态码200
   - 图书成功保存，数据库中该图书价格字段为负值
   - 与测试用例“负价格图书应拦截”的预期结果冲突

2. 扩展测试场景及结果：
   - 在添加新图书时同时输入负价格和其他合法字段：保存成功
   - 在更新已有图书时单独将价格改为负数：更新成功
   - 在批量导入图书数据时包含负价格记录：导入成功，负价格被保留

3. 问题概率：
   - 在多次重复测试中，该问题的出现概率为100%
   - 说明这不是偶发问题，而是数据验证逻辑存在根本性缺陷

4. 日志与用户反馈：
   - 测试日志中未记录任何与负价格相关的错误或警告信息
   - 系统对该异常情况缺乏监控和处理机制
   - 前端页面提交负价格图书信息后：
     - 没有任何错误提示
     - 直接跳转到图书列表页面
     - 新添加的负价格图书会出现在列表中
     - 用户无法知晓自己输入的价格存在问题

### 关联测试点
- 对应《BOOK_TEST_SUMMARY.md》“数据验证 - 异常数据验证”功能点
- 测试用例存在但实际功能未生效
- 违反《TESTING_GUIDE.md》中“数据验证需覆盖所有输入字段的边界值和异常值”的测试规范
- 可能的测试执行问题：
  - 测试环境配置不当
  - 测试数据未完全覆盖
  - 测试结果判断逻辑有误
- 与“错误处理需测试边界条件”的最佳实践相违背
- 系统在面对明显不合理的负价格输入时，没有做出正确的错误响应

### 发现日期
2024-06-12

### 紧急程度
中

### 解决措施
1. 接口层数据验证强化：
   - 在图书添加和更新的接口处明确设置价格的最小值为0
   - 当检测到价格为负数时，返回具体的错误提示
   - 错误提示内容：“图书价格不能为负数，请重新输入”
   - 阻止该图书信息的保存操作

2. 分层校验机制：
   - Controller层：接收请求参数后首先对价格字段进行校验
     - 发现为负数则直接返回HTTP 400错误状态码
     - 在响应体中包含详细的错误信息
   - Service层：添加二次校验，防止因Controller层校验被绕过
   - DAO层：最终数据入库前的校验，形成多层防护机制

3. 前端验证补充：
   - 增加客户端验证，在用户输入价格时实时检测
   - 若输入负数则立即给出提示，避免无效请求发送到后端
   - 输入框添加类型限制，只允许输入数字和小数点

4. 测试用例完善：
   - 补充负价格的拦截情况测试
   - 增加价格为0的边界测试
   - 完善正常正数价格的功能测试
   - 确保验证逻辑的完整性和准确性

5. 历史数据修复：
   - 编写数据修复脚本，处理数据库中已存在的负价格图书
   - 将价格调整为合理的默认值（如0或该图书类别的平均价格）
   - 记录调整日志以便追溯

6. 监控与日志：
   - 在系统日志中增加对价格异常情况的记录
   - 记录内容包括：操作时间、操作人、图书ID、异常价格等
   - 便于后续问题排查和审计

### 责任人
殷科鹏

### 期限
2024-06-17

### 状态
已解决

### 潜在风险
1. 财务风险：
   - 负价格图书可能导致订单结算金额异常
   - 当用户购买负价格图书时，订单总价可能为负数
   - 意味着系统需要向用户支付费用，这在实际业务中是不允许的
   - 可能导致企业资金损失，若被恶意利用损失可能扩大

2. 数据分析风险：
   - 负价格图书的存在会干扰销售数据分析
   - 在计算某类图书的平均价格、总销售额等指标时，负数会拉低整体数据
   - 导致分析结果失真，影响企业决策
   - 可能导致错误的库存策略和采购计划

3. 用户体验风险：
   - 负价格的显示可能让用户对系统的专业性产生怀疑
   - 降低用户信任度，影响用户留存
   - 可能引发用户投诉和质疑

4. 库存管理风险：
   - 若系统根据销售金额自动调整库存预警阈值
   - 负价格可能导致库存预警机制失效
   - 出现该补货时未补货、不该补货时却大量补货的情况
   - 增加库存成本或导致缺货

5. 品牌形象风险：
   - 负价格图书可能会被搜索引擎或第三方平台抓取
   - 影响店铺的线上形象，给品牌带来负面影响
   - 可能被竞争对手利用，损害企业声誉

6. 运营成本风险：
   - 财务部门在对账时发现异常，需要花费大量时间排查原因
   - 增加人力成本
   - 客服部门可能会接到大量关于价格异常的咨询和投诉
   - 增加客服工作负担，影响其他服务工作

