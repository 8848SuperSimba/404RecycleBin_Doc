
# 详细设计说明书
## 一、首页
### （一）程序系统的结构
首页作为图书商城面向普通用户的核心入口，基于Go语言`net/http`标准库构建，采用“请求路由-控制器处理-数据访问”三层架构。
前端通过静态资源（CSS、JS、图片）实现页面渲染，后端通过路由映射（如`/main`、`/getPageBooksByPrice`）将用户请求分发至对应控制器函数，再由控制器调用数据访问层（DAO）接口与数据库交互，最终将图书列表、分页信息、登录状态等数据返回至前端模板，形成完整的用户交互流程。

核心数据流向为：用户请求（分页/筛选/加购）→ 路由匹配 → 控制器处理（参数解析、登录校验、数据查询）→ DAO层操作数据库 → 数据封装（Page对象）→ 模板渲染 → 页面响应。

### （二）单元设计说明
#### 1. 标识符
- 路由标识符：`/main`（首页入口）、`/getPageBooksByPrice`（分页+价格筛选）、`/addBook2Cart`（添加购物车）、`/checkUserName`（用户名校验）
- 控制器函数标识符：`GetPageBooksByPrice`（核心处理函数）、`AddBook2Cart`（购物车操作函数）、`IsLogin`（登录状态校验函数）
- 数据模型标识符：`model.Page`（分页数据模型）、`model.Book`（图书数据模型）、`model.Session`（用户会话模型）

#### 2. 标准表述方式
##### （1）程序描述
首页程序负责接收用户访问请求，支持图书列表分页展示、价格范围筛选、登录状态校验及购物车添加操作。
通过`GetPageBooksByPrice`函数统一处理“默认首页”“分页切换”“价格筛选”三种场景，自动适配有无价格条件的图书查询逻辑；
结合`IsLogin`函数判断用户登录状态，控制“加入购物车”按钮可用性；最终将图书数据、分页导航、登录信息封装到`model.Page`对象，渲染至`views/index.html`模板，向用户呈现完整首页界面。

##### （2）功能
| 功能模块         | 核心逻辑                                                                 | 关联接口/函数                                                                 |
|------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 图书分页展示     | 解析`pageNo`参数（默认1），调用`dao.GetPageBooks`查询对应页图书，计算总页数/总记录数 | `GetPageBooksByPrice`（控制器）、`dao.GetPageBooks`（DAO）、`model.Page`（数据模型） |
| 价格范围筛选     | 解析`min`/`max`参数，调用`dao.GetPageBooksByPrice`查询符合条件图书，回显价格区间   | `GetPageBooksByPrice`（控制器）、`dao.GetPageBooksByPrice`（DAO）              |
| 登录状态控制     | 通过Cookie获取会话ID，调用`dao.IsLogin`校验登录状态，设置`Page.IsLogin`/`Page.Username` | `dao.IsLogin`（DAO）、`model.Session`（会话模型）                            |
| 加入购物车       | 校验登录状态，已登录则调用`dao.AddCartItem`添加购物项，未登录则提示“请先登录”     | `AddBook2Cart`（控制器）、`dao.GetCartByUserID`/`dao.AddCartItem`（DAO）       |
| 库存状态展示     | 前端模板遍历`Page.Books`，根据`Book.Stock`值渲染“加入购物车”按钮（>0）或“补货中”（=0） | `model.Book`（库存字段`Stock`）、`views/index.html`（模板条件渲染）            |

##### （3）性能
- 分页性能：每页默认展示4条图书数据（`dao.GetPageBooks`中`pageSize=4`），通过`LIMIT`语句减少数据库查询量，避免大量数据传输导致的页面加载延迟。
- 并发处理：基于`net/http`内置并发机制，每个请求通过独立Goroutine处理，支持高并发访问，无请求阻塞风险。
- 数据缓存：未登录用户首页数据无缓存，已登录用户购物车数据通过`Session`暂存，减少重复数据库查询。

##### （4）输入说明
| 输入参数         | 数据类型 | 来源          | 说明                                                                 |
|------------------|----------|---------------|----------------------------------------------------------------------|
| `pageNo`         | String   | URL参数       | 分页页码，默认值为“1”，无效值（负数/超总页数）自动跳转至第1页         |
| `min`            | String   | URL参数       | 价格筛选下限，为空时不限制下限，非数字格式提示“请输入有效的价格”       |
| `max`            | String   | URL参数       | 价格筛选上限，为空时不限制上限，非数字格式提示“请输入有效的价格”       |
| `bookId`         | String   | 请求参数（POST） | 图书ID，用于“加入购物车”操作，必填，需与数据库中`books.id`匹配         |
| `user`（Cookie） | String   | 浏览器Cookie  | 会话ID，用于校验用户登录状态，非必填，不存在则视为未登录               |

##### （5）输出说明
| 输出内容         | 数据类型         | 去向          | 说明                                                                 |
|------------------|------------------|---------------|----------------------------------------------------------------------|
| `model.Page`对象 | 结构体           | 模板渲染      | 包含图书列表（`Books`）、分页信息（`PageNo`/`TotalPageNo`）、登录状态（`IsLogin`） |
| 操作提示         | 字符串           | 页面弹窗/文本 | 如“添加成功”“请先登录”“未找到符合条件的图书”“库存不足”                 |
| 静态资源         | CSS/JS/图片      | 浏览器加载    | 从`views/static`目录读取，用于页面样式渲染和交互逻辑实现               |

##### （6）算法
- 分页计算算法：  
  1. 总记录数（`TotalRecord`）：通过`SELECT COUNT(*) FROM books`（或带价格条件）查询。  
  2. 总页数（`TotalPageNo`）：若`TotalRecord % PageSize == 0`，则`TotalPageNo = TotalRecord / PageSize`；否则`TotalPageNo = TotalRecord / PageSize + 1`。  
  3. 分页偏移量：`(PageNo - 1) * PageSize`，用于`LIMIT`语句查询当前页数据。
- 价格筛选算法：  
  1. 若`min`和`max`均为空，执行默认分页查询（`dao.GetPageBooks`）；  
  2. 若任一参数非空，执行带价格条件的查询（`WHERE price BETWEEN ? AND ?`），并将参数回显至`Page.MinPrice`/`Page.MaxPrice`。

##### （7）流程逻辑
1. **首页加载/分页切换流程**：  
   ① 用户访问`/main`或切换页码，请求携带`pageNo`参数；  
   ② `GetPageBooksByPrice`解析`pageNo`（默认1），判断是否有价格筛选参数；  
   ③ 调用对应DAO函数查询图书数据及总记录数，计算总页数；  
   ④ 校验用户登录状态，设置`Page`对象的`IsLogin`和`Username`；  
   ⑤ 渲染`views/index.html`，展示图书列表及分页导航（首页/上一页/下一页/末页）。

2. **价格筛选流程**：  
   ① 用户输入`min`/`max`并提交，请求携带价格参数；  
   ② 前端校验参数格式（非数字提示错误）；  
   ③ 后端调用`dao.GetPageBooksByPrice`查询符合条件的图书；  
   ④ 若无结果，页面显示“未找到符合条件的图书”；否则渲染筛选后的列表。

3. **加入购物车流程**：  
   ① 用户点击“加入购物车”，请求携带`bookId`；  
   ② 调用`dao.IsLogin`校验登录状态：  
      - 未登录：返回“请先登录”提示；  
      - 已登录：查询用户购物车，若存在该图书则更新数量，否则创建新购物项；  
   ③ 更新购物车总数量/总金额，返回“添加成功”提示。

##### （8）接口
| 接口类型         | 接口名称/路径          | 功能描述                                                                 | 参数说明                                                                 |
|------------------|-----------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 路由接口         | `/main`               | 首页入口，映射至`GetPageBooksByPrice`函数                                 | 支持`pageNo`/`min`/`max`URL参数                                          |
| 路由接口         | `/addBook2Cart`       | 添加图书到购物车，映射至`AddBook2Cart`函数                                 | 需`bookId`请求参数，依赖`user`Cookie（会话ID）                          |
| DAO接口          | `dao.GetPageBooks`    | 查询带分页的图书数据，无价格筛选                                         | 入参：`pageNo`（String）；出参：`*model.Page`、`error`                    |
| DAO接口          | `dao.GetPageBooksByPrice` | 查询带分页和价格筛选的图书数据                                         | 入参：`pageNo`/`min`/`max`（均为String）；出参：`*model.Page`、`error`     |
| DAO接口          | `dao.IsLogin`         | 校验用户登录状态                                                         | 入参：`*http.Request`；出参：`flag`（Boolean）、`*model.Session`          |

##### （9）存储分配
- 静态资源存储：CSS、JS、图书封面图片存储于`views/static`目录，通过`http.Handle("/static/", ...)`配置静态资源路由，浏览器直接加载。  
- 数据存储：图书信息（ID、名称、作者、价格等）存储于MySQL数据库`bookstore0612`的`books`表，字段与`model.Book`结构体一一对应（如`id`对应`Book.ID`，`img_path`对应`Book.ImgPath`）。  
- 会话存储：用户登录状态通过`Session`存储于` sessions`表，`SessionID`（UUID）通过Cookie传递，关联用户ID和用户名。

##### （10）注释设计
- 路由配置注释：`main.go`中每个`http.HandleFunc`均添加功能说明，如`//去首页`“//添加图书到购物车中”。  
- 控制器函数注释：`bookhandler.go`中`GetPageBooksByPrice`函数注释包含功能描述、参数解析逻辑、数据处理流程。  
- DAO函数注释：`bookdao.go`中`GetPageBooksByPrice`注释说明SQL逻辑（价格条件、分页`LIMIT`）及返回值含义。  
- 模板注释：`views/index.html`中添加条件渲染注释，如`<!-- 库存>0显示加购按钮，否则显示补货中 -->`。

##### （11）限制条件
- 价格筛选限制：`min`不能大于`max`，否则无查询结果；非数字输入会触发前端校验错误，无法提交。  
- 分页限制：`pageNo`为负数或大于`TotalPageNo`时，自动跳转至第1页；`pageSize`固定为4（DAO层硬编码），不支持用户自定义。  
- 库存限制：`Book.Stock == 0`时，“加入购物车”按钮置灰，无法触发加购操作；加购时若库存不足（如当前库存1，请求加购2），需补充前端校验逻辑。

##### （12）测试计划
| 测试场景         | 测试用例                                                                 | 预期结果                                                                 |
|------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 首页默认加载     | 访问`http://localhost:8080/main`，无任何参数                              | 加载第1页图书（4条），显示分页导航（总页数/总记录数正确），未登录状态下“加入购物车”提示登录 |
| 分页切换         | 访问`http://localhost:8080/main?pageNo=2`                                 | 加载第2页图书，分页导航当前页显示“2”，“上一页”可点击，“下一页”根据总页数判断是否可点击 |
| 价格筛选（有效） | 访问`http://localhost:8080/main?min=50&max=100`                           | 显示价格在50-100元之间的图书，筛选条件回显在页面，分页信息匹配筛选结果       |
| 价格筛选（无效） | 访问`http://localhost:8080/main?min=abc`                                   | 前端提示“请输入有效的价格”，不发起后端请求                                 |
| 加入购物车（已登录） | 登录后点击某本库存>0图书的“加入购物车”按钮                                 | 提示“添加成功”，数据库`cart_items`表新增/更新对应记录，购物车总数量增加       |
| 加入购物车（未登录） | 未登录时点击“加入购物车”按钮                                             | 提示“请先登录”，不操作数据库                                               |

##### （13）尚未解决的问题
- 前端校验缺失：价格筛选的`min`> `max`场景、加购数量超过库存场景，目前仅后端隐含处理（无结果/不更新），需补充前端实时校验。  
- 静态资源缓存：图书封面图片未设置缓存头，每次访问均重新加载，影响页面加载速度，需配置`Cache-Control`响应头。  
- 分页样式适配：当总页数过多（如100页）时，分页导航会横向溢出，需优化为“省略号”样式（如1...3 4 5...100）。


## 二、图书管理页
### （一）程序系统的结构
图书管理页面向管理员角色，基于“路由-控制器-DAO”架构实现图书的增删改查（CRUD）操作。后端通过`/getPageBooks`（分页列表）、`/deleteBook`（删除）、`/toUpdateBookPage`（跳转编辑页）、`/updateOraddBook`（新增/编辑）等路由，将管理员请求分发至对应控制器函数；控制器调用DAO层接口操作`books`表，实现数据持久化；前端通过`views/pages/manager/book_manager.html`（列表页）和`book_edit.html`（编辑页）实现管理界面渲染，仅允许管理员访问（依赖会话权限判断）。

核心数据流向为：管理员操作（分页/删除/编辑/新增）→ 路由匹配 → 控制器处理（参数解析、权限隐含校验）→ DAO层操作数据库 → 页面刷新/跳转 → 展示更新后的图书列表。

### （二）单元设计说明
#### 1. 标识符
- 路由标识符：`/getPageBooks`（管理页列表）、`/deleteBook`（删除图书）、`/toUpdateBookPage`（跳转编辑页）、`/updateOraddBook`（新增/编辑提交）
- 控制器函数标识符：`GetPageBooks`（列表处理）、`DeleteBook`（删除处理）、`ToUpdateBookPage`（跳转编辑页）、`UpdateOrAddBook`（新增/编辑处理）
- 数据模型标识符：`model.Page`（分页数据模型）、`model.Book`（图书数据模型）

#### 2. 标准表述方式
##### （1）程序描述
图书管理页程序为管理员提供图书全生命周期管理功能，支持分页查看图书列表、单本删除图书、编辑已有图书信息、新增图书。通过`GetPageBooks`函数加载分页图书列表，默认每页4条数据；`DeleteBook`函数实现图书删除（含确认弹窗），删除后自动刷新当前页；`ToUpdateBookPage`函数根据是否携带`bookId`，跳转至“编辑页”（预填数据）或“新增页”（空表单）；`UpdateOrAddBook`函数统一处理新增/编辑提交，根据`bookId`是否大于0判断操作类型，最终更新数据库并返回列表页。

##### （2）功能
| 功能模块         | 核心逻辑                                                                 | 关联接口/函数                                                                 |
|------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 图书分页列表     | 解析`pageNo`参数（默认1），调用`dao.GetPageBooks`查询对应页图书，渲染管理列表 | `GetPageBooks`（控制器）、`dao.GetPageBooks`（DAO）、`book_manager.html`（模板） |
| 图书删除         | 接收`bookId`参数，调用`dao.DeleteBook`删除数据库记录，刷新当前页列表       | `DeleteBook`（控制器）、`dao.DeleteBook`（DAO）                              |
| 图书编辑跳转     | 接收`bookId`参数，调用`dao.GetBookByID`查询图书详情，跳转至`book_edit.html`预填表单 | `ToUpdateBookPage`（控制器）、`dao.GetBookByID`（DAO）                        |
| 图书新增/编辑提交 | 接收表单参数（名称/作者/价格等），判断`bookId`是否大于0：<br>- 是：调用`dao.UpdateBook`更新<br>- 否：调用`dao.AddBook`新增 | `UpdateOrAddBook`（控制器）、`dao.UpdateBook`/`dao.AddBook`（DAO）            |
| 管理员权限控制   | 隐含依赖`dao.IsLogin`校验会话，仅`Session`有效且为管理员角色可访问（需补充显式权限判断） | `dao.IsLogin`（DAO）、`model.Session`（会话模型）                            |

##### （3）性能
- 分页性能：与首页一致，每页4条数据，通过`LIMIT`减少数据库查询量，适合管理员高效管理（避免大量数据加载）。  
- 数据操作性能：删除/新增/编辑操作均为单条SQL执行（`DELETE`/`INSERT`/`UPDATE`），无复杂联表，响应延迟低。  
- 并发控制：管理员操作通常为单人或少量人，无高并发场景，`net/http`的Goroutine机制可满足并发需求。

##### （4）输入说明
| 输入参数         | 数据类型 | 来源          | 说明                                                                 |
|------------------|----------|---------------|----------------------------------------------------------------------|
| `pageNo`         | String   | URL参数       | 分页页码，默认值为“1”，无效值自动跳转至第1页                             |
| `bookId`         | String   | URL参数（删除/编辑） | 图书ID，用于定位待删除/待编辑的图书，必填，需与`books.id`匹配             |
| `title`          | String   | 表单参数（新增/编辑） | 图书名称，必填，非空校验（需补充前端逻辑）                               |
| `author`         | String   | 表单参数（新增/编辑） | 图书作者，必填，非空校验（需补充前端逻辑）                               |
| `price`          | String   | 表单参数（新增/编辑） | 图书价格，必填，需为数字且保留两位小数（需补充前端校验）                   |
| `sales`          | String   | 表单参数（新增/编辑） | 图书销量，必填，需为非负整数（需补充前端校验）                             |
| `stock`          | String   | 表单参数（新增/编辑） | 图书库存，必填，需为非负整数（需补充前端校验）                             |

##### （5）输出说明
| 输出内容         | 数据类型         | 去向          | 说明                                                                 |
|------------------|------------------|---------------|----------------------------------------------------------------------|
| `model.Page`对象 | 结构体           | 列表页渲染    | 包含图书列表（`Books`）、分页信息（`PageNo`/`TotalPageNo`/`TotalRecord`） |
| `model.Book`对象 | 结构体           | 编辑页渲染    | 包含待编辑图书的所有字段（`ID`/`Title`/`Author`等），用于表单预填         |
| 操作结果         | 页面跳转/列表刷新 | 管理页        | 删除/新增/编辑后自动跳转回`book_manager.html`，展示更新后的列表           |
| 异常提示         | 页面文本         | 编辑页/列表页 | 如数据库操作失败时，列表页不刷新（保留原数据），编辑页无提示（需补充错误反馈） |

##### （6）算法
- 分页计算算法：与首页完全一致，基于`TotalRecord`和`pageSize=4`计算`TotalPageNo`，通过`(PageNo-1)*PageSize`确定`LIMIT`偏移量。  
- 新增/编辑判断算法：在`UpdateOrAddBook`函数中，通过`book.ID > 0`判断操作类型：  
  - `book.ID > 0`：编辑操作，调用`dao.UpdateBook`执行`UPDATE books SET ... WHERE id=?`；  
  - `book.ID == 0`：新增操作，调用`dao.AddBook`执行`INSERT INTO books (...) VALUES (...)`，默认封面图路径为`/static/img/default.jpg`。

##### （7）流程逻辑
1. **管理页加载/分页切换流程**：  
   ① 管理员访问`/getPageBooks`，请求携带`pageNo`参数（默认1）；  
   ② `GetPageBooks`解析`pageNo`，调用`dao.GetPageBooks`查询对应页图书及分页信息；  
   ③ 渲染`book_manager.html`，展示图书列表（含ID/名称/作者/价格/销量/库存）及分页导航、“添加图书”按钮、“删除/修改”操作列。

2. **图书删除流程**：  
   ① 管理员点击某图书的“删除”按钮，触发确认弹窗（提示“确定要删除【xxx】吗？”）；  
   ② 确认后，请求携带`bookId`调用`/deleteBook`；  
   ③ `DeleteBook`调用`dao.DeleteBook`删除数据库记录；  
   ④ 调用`GetPageBooks`刷新当前页列表：若删除后当前页无数据，自动跳转至上一页。

3. **图书编辑流程**：  
   ① 管理员点击某图书的“修改”按钮，请求携带`bookId`调用`/toUpdateBookPage`；  
   ② `ToUpdateBookPage`调用`dao.GetBookByID`查询图书详情；  
   ③ 跳转至`book_edit.html`，表单预填图书当前信息（如`title`输入框填`Book.Title`）；  
   ④ 管理员修改表单后提交，请求携带所有字段调用`/updateOraddBook`；  
   ⑤ `UpdateOrAddBook`判断`bookId > 0`，调用`dao.UpdateBook`更新数据库；  
   ⑥ 跳转回`book_manager.html`，列表显示更新后的图书信息。

4. **图书新增流程**：  
   ① 管理员点击“添加图书”按钮，请求无`bookId`调用`/toUpdateBookPage`；  
   ② `ToUpdateBookPage`判断`book.ID == 0`，跳转至`book_edit.html`，显示空表单；  
   ③ 管理员填写表单后提交，请求携带所有字段调用`/updateOraddBook`；  
   ④ `UpdateOrAddBook`判断`bookId == 0`，调用`dao.AddBook`新增数据库记录（默认封面图路径）；  
   ⑤ 跳转回`book_manager.html`，列表新增该图书记录。

##### （8）接口
| 接口类型         | 接口名称/路径          | 功能描述                                                                 | 参数说明                                                                 |
|------------------|-----------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 路由接口         | `/getPageBooks`       | 管理页列表入口，映射至`GetPageBooks`函数                                 | 支持`pageNo`URL参数，默认1                                              |
| 路由接口         | `/deleteBook`         | 删除图书，映射至`DeleteBook`函数                                         | 需`bookId`URL参数（如`/deleteBook?bookId=1001`）                        |
| 路由接口         | `/toUpdateBookPage`   | 跳转编辑/新增页，映射至`ToUpdateBookPage`函数                             | 可选`bookId`URL参数（编辑时必填，新增时无）                              |
| 路由接口         | `/updateOraddBook`    | 新增/编辑提交，映射至`UpdateOrAddBook`函数                                | 需表单参数：`bookId`（隐藏域）、`title`、`author`、`price`、`sales`、`stock` |
| DAO接口          | `dao.GetBookByID`     | 根据`bookId`查询单本图书详情                                             | 入参：`bookId`（String）；出参：`*model.Book`、`error`                    |
| DAO接口          | `dao.DeleteBook`      | 根据`bookId`删除图书记录                                                 | 入参：`bookId`（String）；出参：`error`                                  |
| DAO接口          | `dao.AddBook`         | 新增图书记录                                                             | 入参：`*model.Book`；出参：`error`                                      |
| DAO接口          | `dao.UpdateBook`      | 更新图书记录                                                             | 入参：`*model.Book`；出参：`error`                                      |

##### （9）存储分配
- 管理页模板存储：`book_manager.html`（列表页）和`book_edit.html`（编辑页）存储于`views/pages/manager`目录，通过`http.Handle("/pages/", ...)`配置路由，仅管理员可访问。  
- 图书数据存储：与首页共享`books`表，新增图书时默认封面图路径`/static/img/default.jpg`，存储于`img_path`字段；编辑时可修改除`ID`外的所有字段（`title`/`author`/`price`等）。  
- 权限关联存储：管理员角色信息隐含在`Session`中（需补充显式权限字段，如`Session.Role`），目前仅通过“是否登录”判断，需后续优化为“角色校验”。

##### （10）注释设计
- 路由注释：`main.go`中`/getPageBooks`注释为“获取带分页的图书信息”，`/deleteBook`注释为“删除图书”，明确功能用途。  
- 控制器函数注释：`bookhandler.go`中`DeleteBook`注释包含“获取`bookId`→调用DAO删除→刷新列表”流程；`UpdateOrAddBook`注释区分“新增”和“编辑”逻辑。  
- DAO函数注释：`bookdao.go`中`AddBook`/`UpdateBook`/`DeleteBook`注释说明SQL语句用途及参数含义（如`AddBook`注释“向`books`表插入图书记录”）。  
- 模板注释：`book_edit.html`中表单字段添加注释，如`<!-- 图书ID，编辑时显示，新增时隐藏 -->`。

##### （11）限制条件
- 权限限制：目前仅通过“是否登录”判断访问权限，普通用户若知道路由（如`/getPageBooks`）可绕过访问，需补充显式角色校验（如`Session.Role == "admin"`）。  
- 数据格式限制：表单提交的`price`（需float64）、`sales`/`stock`（需int）未做前端校验，若输入非数字，后端`strconv.Parse`会返回默认值（0），导致数据错误。  
- 删除限制：删除图书时未关联购物车/订单数据（如某图书已在用户购物车中，删除后购物车查询会报错），需补充“关联数据检查”（如存在关联则禁止删除或提示）。

##### （12）测试计划
| 测试场景         | 测试用例                                                                 | 预期结果                                                                 |
|------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 管理页加载       | 管理员登录后访问`http://localhost:8080/getPageBooks`                     | 加载第1页图书列表（4条），显示“删除/修改”按钮、“添加图书”链接，分页导航正常 |
| 分页切换         | 访问`http://localhost:8080/getPageBooks?pageNo=3`                         | 加载第3页图书，分页导航当前页为3，“上一页”跳至2，“下一页”根据总页数判断     |
| 图书删除         | 点击某图书“删除”→确认弹窗→确认                                           | 图书从列表中消失，`books`表对应记录删除；若当前页无数据，自动跳转至上一页   |
| 图书编辑         | 点击某图书“修改”→修改价格→提交                                           | 编辑页预填原数据，提交后列表显示新价格，`books`表`price`字段更新           |
| 图书新增         | 点击“添加图书”→填写表单（名称/作者/价格等）→提交                           | 列表新增该图书，`books`表新增记录，默认封面图路径正确                     |
| 权限校验（普通用户） | 普通用户访问`http://localhost:8080/getPageBooks`                         | 跳转至登录页或提示“无权限访问”（需补充功能后验证）                         |
| 表单错误输入     | 编辑图书时，`price`输入“abc”→提交                                         | 前端提示“请输入有效的价格”（需补充校验后验证）；无校验时后端`price`为0.00   |

##### （13）尚未解决的问题
- 权限漏洞：普通用户可通过直接访问路由绕过权限，需新增“角色校验中间件”，在`GetPageBooks`/`DeleteBook`等函数前校验`Session.Role`。  
- 关联数据未处理：删除图书时未检查是否存在购物车项（`cart_items`）、订单项（`order_items`），删除后会导致关联查询`book_id`不存在，需补充“级联删除”或“禁止删除”逻辑。  
- 编辑页体验：编辑时封面图无法修改（默认路径固定），需新增“图片上传”功能，支持管理员自定义封面图。  
- 错误反馈缺失：数据库操作失败（如网络中断）时，页面无任何提示（如删除失败仍显示原列表），需补充错误弹窗或文本提示。

## 三、购物车页
### （一）程序系统的结构
购物车页作为图书商城用户管理待购图书的核心交互页面，基于 “前端路由 - 页面逻辑 - 后端接口调用” 三层架构设计（前端采用 Vue/React 框架，后端对接购物车模块Mod-Cart）。
前端通过路由（如/cart）接收用户访问请求，页面逻辑层负责解析用户操作（数量修改、删除、结账）、调用后端接口（如/api/cart/info）、处理接口响应并更新视图；
后端接口由购物车模块提供，实现数据查询、库存校验、事务更新等核心逻辑，最终通过 “用户操作→前端请求→后端处理→前端渲染” 的流程，完成购物车全生命周期的交互。
核心数据流向为：用户操作（加载购物车 / 修改数量 / 删除 / 结账）→ 前端路由匹配 → 页面逻辑层（参数组装、登录校验）→ 调用后端购物车模块接口 → 后端 DAO 层操作数据库 / 缓存 → 接口返回数据 → 前端渲染（列表 / 总金额 / 提示信息）→ 页面响应。

### （二）单元设计说明
#### 1. 标识符
- **单元名称**：购物车模块
- **标识符**：`Mod-Cart`
- **所属子系统**：购物车子系统

#### 2. 标准表述方式
##### （1）程序描述
本程序（模块）负责**用户购物车的全生命周期管理**，包括购物车数据加载、购物项数量修改、购物车清空、结账前库存校验等功能，支撑“用户暂存待购图书→提交订单”的核心流程。

##### （2）功能
- **基础功能**：
  - 加载购物车数据（含购物项列表、总数量、总金额）；
  - 修改购物项购买数量（含实时库存校验）；
  - 删除单个购物项；
  - 清空购物车；
- **辅助功能**：
  - 结账前全购物项库存校验；
  - 购物车数据缓存与数据库同步。

##### （3）性能
- **响应时间**：
  - 购物车数据加载（`GetCartInfo`）：缓存命中时 ≤ 200ms，缓存未命中时 ≤ 500ms；
  - 购物项数量修改（`UpdateCartItemCount`）：≤ 300ms（含库存查询与事务提交）；
- **并发能力**：单接口支持 500+ 并发请求（Redis + MySQL 索引保障）。

##### （4）输入说明
| 接口名称 | 输入参数（关键） | 输入来源 | 输入格式 |
|----------|------------------|----------|----------|
| `GetCartInfo` | `user_id`（从 token 解析） | 用户认证模块 | 无（接口无 URL 参数） |
| `UpdateCartItemCount` | `item_id`、`new_count` | 前端数量控件操作 | JSON 格式 |
| `CheckCartForCheckout` | `cart_id` | 结账模块请求 | JSON 格式 |

##### （5）输出说明
| 接口名称 | 输出数据（关键） | 输出去向 | 输出格式 |
|----------|------------------|----------|----------|
| `GetCartInfo` | 购物车数据（`cart_id`、`items`、`total_quantity` 等） | 前端购物车页面 | JSON 格式 |
| `UpdateCartItemCount` | 更新后购物项与购物车统计数据 | 前端购物车页面 | JSON 格式 |
| `CheckCartForCheckout` | 校验结果（`is_valid`、`invalid_items`） | 结账模块 | JSON 格式 |

##### （6）算法
- **库存校验算法**（`UpdateCartItemCount`/`CheckCartForCheckout`）：
  1. 输入：目标图书ID（`book_id`）、请求数量（`req_count`）；
  2. 步骤：
     - 查询 `book` 表，获取当前库存 `current_stock`；
     - 比较 `req_count` 与 `current_stock`：
       - 若 `req_count ≤ current_stock`：校验通过；
       - 若 `req_count > current_stock`：校验失败，返回库存不足信息；
  3. 输出：校验结果（布尔值）+ 库存不足时的详细信息（如 `book_name`、`current_stock`）。

##### （7）流程逻辑
1. 前端触发数量修改（点击“+”/“-”或输入框失焦）；
2. 前端调用 `UpdateCartItemCount` 接口，传入 `item_id`、`new_count`；
3. 后端校验：
   - `new_count` 是否为正整数；
   - 调用“库存校验算法”，检查图书库存是否充足；
4. 若校验通过：
   - 开启数据库事务；
   - 更新 `cart_item` 表的 `buy_quantity` 和 `item_amount`；
   - 更新 `cart` 表的 `total_quantity` 和 `total_amount`；
   - 提交事务；
   - 更新 Redis 缓存（`cart:user:{user_id}`）；
5. 若校验失败：
   - 回滚事务；
   - 返回错误码（如 1003-库存不足）与提示信息；
6. 前端接收响应，更新页面展示（如数量、小计、总金额）。

##### （8）接口
- **对外提供接口（RESTful）**：
| 接口名称 | 请求方式 | URL | 权限控制 |
|----------|----------|-----|----------|
| `GetCartInfo` | GET | `/api/cart/info` | 需用户登录 |
| `UpdateCartItemCount` | PUT | `/api/cart/item/count` | 需用户登录 |
| `CheckCartForCheckout` | POST | `/api/cart/checkout` | 需用户登录 |
- **依赖内部接口**：
  - `CheckUserLogin`（用户认证模块）：验证用户 token 有效性；
  - `GetBookStock`（图书信息模块）：查询图书实时库存。

##### （9）存储分配
- **缓存存储（Redis）**：
  - Key：`cart:user:{user_id}`
  - 类型：Hash
  - 字段：`cart_id`、`total_quantity`、`total_amount`、`items`（嵌套购物项 JSON 数组）
  - 过期时间：7天
- **持久化存储（MySQL）**：
  - 表：`cart`（购物车主表）、`cart_item`（购物项明细表）
  - 索引：`cart` 表 `user_id` 索引，`cart_item` 表 `cart_id` 外键索引

##### （10）注释设计
- **代码注释规范**：
  - 方法级注释：使用 `/** 描述 */`，说明方法功能、参数、返回值、异常；
  - 关键逻辑注释：如事务开启/提交、缓存更新等步骤，标注 `// 事务：更新购物车数据`；
  - 数据库实体类：字段注释与表结构文档对齐（如 `@TableField(comment = "购物车总数量")`）；
- **文档注释关联**：代码注释需关联本详细设计文档（如“参考详细设计说明书 3.1.2 节”）。

##### （11）限制条件
- **技术限制**：
  - Redis 缓存最大单 Key 大小 ≤ 10MB（购物车数据需控制，避免单个用户购物项过多）；
  - MySQL 事务隔离级别为 `READ COMMITTED`（避免脏读，保障库存校验准确性）；
- **业务限制**：
  - 单购物项最大购买数量 ≤ 99（防止恶意刷单或库存超卖）；
  - 购物车仅保留最近 30 天未操作则清空（由 Redis 过期时间保障）。

##### （12）测试计划
- **测试类型**：
  - 单元测试：覆盖核心方法（如库存校验、购物车统计计算）；
  - 接口测试：验证所有对外接口的请求/响应格式、异常码；
  - 集成测试：与用户认证模块、图书信息模块联调；
  - 性能测试：模拟 500+ 并发修改购物项数量，验证响应时间与数据一致性；
- **测试用例示例**：
| 用例名称 | 步骤 | 预期结果 |
|----------|------|----------|
| 库存不足修改 | 图书库存为 2，请求修改数量为 3 | 返回错误码 1003，提示“库存不足” |
| 缓存同步 | 修改购物项数量后，查询 Redis 缓存 | 缓存中 `buy_quantity` 与数据库一致 |

##### （13）尚未解决的问题
- 未登录用户购物车与登录后合并规则不明确：当用户从“未登录（localStorage 存储）”切换为“登录（Redis 存储）”时，相同图书是否“叠加数量”或“覆盖”，需产品进一步明确；
- 购物车数据实时性与性能平衡：库存校验每次都查询数据库，若并发过高可能影响性能，是否引入“库存缓存”需评估（但会降低实时性）。

## 四、管理员订单管理页
### （一）程序系统的结构
定位与架构：作为图书商城管理员处理订单的核心后台页，采用 “管理员路由 - 页面逻辑 - 后端 Mod-AdminOrder” 三层架构，前端基于 Vue+Element UI 实现。
核心交互流程：前端通过专属路由（如/admin/orders）接收访问请求，页面逻辑层解析管理员操作（订单筛选、查看详情、发货）、调用后端接口（如/api/admin/orders/list）并更新视图；
后端由 Mod-AdminOrder 提供接口，实现订单查询、状态流转、物流信息存储等核心逻辑。
核心数据流向：管理员操作→前端路由匹配→页面逻辑层（参数组装、权限校验）→调用后端订单接口→后端 DAO 层操作数据库→接口返回数据→前端渲染（订单列表 / 详情 / 物流信息）→页面响应。

### （二）单元设计说明
#### 1. 标识符
- **单元名称**：管理员订单管理模块
- **标识符**：`Mod-AdminOrder`
- **所属子系统**：管理员订单管理子系统

#### 2. 标准表述方式
##### （1）程序描述

本程序（模块）负责**管理员视角的订单全生命周期管理**，核心功能为订单列表查询（支持状态筛选、分页）与订单发货操作，支撑“订单审核→发货→售后”的后端流程。

##### （2）功能
- **核心功能**：
  - 多状态订单列表查询（分页、筛选）；
  - 订单发货操作（更新状态、录入物流信息）；
- **扩展功能（待迭代）**：
  - 订单取消/退款处理；
  - 订单导出（Excel 格式）。

##### （3）性能
- **响应时间**：
  - 订单列表查询（`GetAdminOrdersList`）：≤ 500ms（单页 10 条数据，含关联订单项）；
  - 订单发货操作（`UpdateOrderToShipped`）：≤ 300ms（含事务与通知触发）；
- **并发能力**：单接口支持 200+ 并发请求（管理员操作频率低于用户，优先级次之）。

##### （4）输入说明
| 接口名称 | 输入参数（关键） | 输入来源 | 输入格式 |
|----------|------------------|----------|----------|
| `GetAdminOrdersList` | `order_status`、`page_num`、`page_size` | 管理员筛选/分页操作 | URL 参数 |
| `UpdateOrderToShipped` | `order_id`、`logistics_company`、`logistics_no` | 管理员发货操作 | JSON 格式 |

##### （5）输出说明
| 接口名称 | 输出数据（关键） | 输出去向 | 输出格式 |
|----------|------------------|----------|----------|
| `GetAdminOrdersList` | 订单列表、分页信息 | 管理员订单管理页面 | JSON 格式 |
| `UpdateOrderToShipped` | 发货后订单状态、物流信息 | 管理员订单详情页 | JSON 格式 |

##### （6）算法
- **订单状态流转算法**（`UpdateOrderToShipped`）：
  1. 输入：`order_id`、`logistics_company`、`logistics_no`；
  2. 步骤：
     - 查询订单当前状态 `current_status`；
     - 若 `current_status != 1`（非“已支付待发货”）：终止流程，返回状态错误；
     - 若 `current_status == 1`：更新状态为 2（已发货），并存储物流信息；
  3. 输出：更新后订单状态与物流信息。

##### （7）流程逻辑
1. 管理员在订单列表中，点击“待发货”订单的“发货”按钮；
2. 前端弹窗，输入“物流公司”“物流单号”，点击“确认发货”；
3. 前端调用 `UpdateOrderToShipped` 接口，传入 `order_id`、`logistics_company`、`logistics_no`；
4. 后端校验：
   - 订单状态是否为“已支付待发货”；
   - 物流单号格式是否符合规则（如正则 `/^[A-Z0-9]{8,20}$/`）；
5. 若校验通过：
   - 开启数据库事务；
   - 更新 `order` 表的 `status` 为 2、`status_text` 为“已发货”、`logistics_company`、`logistics_no`、`update_time`；
   - 提交事务；
   - （可选）调用消息通知模块，发送“订单已发货”通知；
6. 若校验失败：
   - 回滚事务；
   - 返回错误码（如 1006-订单状态错误）与提示信息；
7. 前端接收响应，更新订单状态为“已发货”，并展示物流信息。

##### （8）接口
- **对外提供接口（RESTful）**：
| 接口名称 | 请求方式 | URL | 权限控制 |
|----------|----------|-----|----------|
| `GetAdminOrdersList` | GET | `/api/admin/orders/list` | 需管理员权限 |
| `UpdateOrderToShipped` | PUT | `/api/admin/orders/shipped` | 需管理员权限 |

- **依赖内部接口**：
  - `IsAdminLogin`（用户认证模块）：验证管理员 token 有效性；
  - `SendNotification`（消息通知模块，待对接）：发送订单状态变更通知。

##### （9）存储分配
- **持久化存储（MySQL）**：
  - 表：`order`（订单主表）、`order_item`（订单项明细表）；
  - 索引：`order` 表 `status` 普通索引、`status + create_time` 联合索引；`order_item` 表 `order_id` 外键索引；
- **缓存存储**（暂未使用 Redis）：订单数据为低频修改（管理员操作），且需强一致性，暂不缓存，直接查询数据库。

##### （10）注释设计
- **代码注释规范**：
  - 服务层方法（如 `orderService.shipOrder()`）：注释说明“订单发货的全流程，含状态校验、事务控制”；
  - 数据库操作（如 `update order set status=2...`）：注释关联需求用例“UC-3.4.4 订单发货”；
- **文档关联**：关键逻辑（如物流单号校验正则）需标注“参考详细设计说明书 3.2.2 节”。

##### （11）限制条件
- **技术限制**：
  - 物流单号仅支持数字与大写字母，长度 8-20 位（由正则 `/^[A-Z0-9]{8,20}$/` 限制）；
  - 订单状态流转不可逆（如“已发货”无法回退为“待发货”，需走退款流程）；
- **业务限制**：
  - 仅“已支付待发货”状态的订单可执行发货操作；
  - 物流信息一旦提交，不可修改（需保障物流单的唯一性与可追溯性）。

##### （12）测试计划
- **测试类型**：
  - 接口测试：验证 `GetAdminOrdersList` 的筛选、分页功能，`UpdateOrderToShipped` 的状态校验、物流单号校验；
  - 集成测试：与用户认证模块联调，验证管理员权限控制；
  - 异常测试：对“已发货”订单重复调用发货接口，验证返回“状态错误”；
- **测试用例示例**：

| 用例名称 | 步骤 | 预期结果 |
|----------|------|----------|
| 状态筛选 | 请求 `order_status=2`（已发货） | 仅返回 `status=2` 的订单 |
| 无效物流单号 | 输入物流单号为“abcdefg”（长度7） | 返回错误码 1007，提示“物流单号格式无效” |

##### （13）尚未解决的问题
- 消息通知模块对接延迟：订单发货后需通知用户，但消息模块的接口文档与联调计划尚未确定，可能导致“发货后用户无感知”的问题；
- 订单批量操作支持：当前仅支持单订单发货，若需“批量发货”（如同一物流公司的 100 单），需扩展接口与前端功能，暂未纳入本次设计。

# 五、个人订单页
## （一）程序系统的结构
个人订单页作为用户查看自身订单信息的核心页面，基于 Go 语言`net/http`标准库构建，采用 “请求路由 - 控制器处理 - 数据访问” 三层架构。
前端通过静态资源实现页面渲染，后端通过路由映射（`/getMyOrders`）将用户请求分发至对应控制器函数，控制器调用数据访问层（DAO）接口查询用户相关订单数据，最终将订单列表、订单状态等数据返回至前端模板，完成用户与订单信息的交互流程。
核心数据流向为：**用户请求（查看个人订单）→ 路由匹配 → 控制器处理（登录校验、订单查询）→ DAO 层操作数据库 → 数据封装（Order 对象列表）→ 模板渲染 → 页面响应**。
## （二）单元设计说明
### 1. 标识符
- 路由标识符：`/getMyOrders`（获取个人订单）、`/takeOrder`（确认收货）
- 控制器函数标识符：`GetMyOrders`（核心处理函数）、`TakeOrder`（订单状态更新函数）
- 数据模型标识符：`model.Order`（订单数据模型）、`model.Session`（用户会话模型）

### 2. 标准表述方式
#### （1）程序描述
个人订单页负责接收已登录用户的订单查询请求，展示用户所有订单的基本信息，包括订单号、创建时间、总数量、总金额、订单状态等，并支持用户对 “已发货” 状态的订单执行 “确认收货” 操作。

通过`GetMyOrders`函数从数据库查询当前登录用户的所有订单，封装到`model.Session`对象中，渲染至`views/pages/order/order.html`模板；当用户点击 “确认收货” 按钮时，调用`TakeOrder`函数更新订单状态为 “已收货”，并重新加载订单列表。

#### （2）功能
| 功能模块         | 核心逻辑                                                                 | 关联接口 / 函数                                           |
|------------------|--------------------------------------------------------------------------|-----------------------------------------------------------|
| 个人订单查询     | 校验用户登录状态，通过用户 ID 调用`dao.GetMyOrders`查询所有订单，按创建时间排序 | `GetMyOrders`（控制器）、`dao.GetMyOrders`（DAO）、`model.Order`（数据模型） |
| 订单状态展示     | 前端模板根据`Order.State`值展示对应状态文本（0 - 未发货 / 1 - 已发货 / 2 - 已收货） | `model.Order`（状态字段`State`）、`views/pages/order/order.html`（模板渲染） |
| 确认收货操作     | 接收订单号参数，调用`dao.UpdateOrderState`将订单状态更新为 2（已收货）     | `TakeOrder`（控制器）、`dao.UpdateOrderState`（DAO）       |
| 订单详情跳转     | 提供订单详情链接，携带订单号参数跳转至订单详情页                           | `views/pages/order/order.html`（模板链接）、`/getOrderInfo`（路由） |

#### （3）性能
- **数据查询性能**：通过用户 ID 精准查询订单（`WHERE user_id = ?`），减少数据扫描范围；订单数据按创建时间倒序排列（默认最新订单在前），提升用户查找体验。
- **状态更新性能**：确认收货操作通过订单号（`order_id`）执行`UPDATE`语句，基于主键索引，更新效率高，无性能瓶颈。
- **并发处理**：基于`net/http`并发机制，支持多用户同时查询和操作订单，互不干扰。

#### （4）输入说明
| 输入参数         | 数据类型 | 来源          | 说明                                                                 |
|------------------|----------|---------------|----------------------------------------------------------------------|
| `user`（Cookie） | String   | 浏览器 Cookie | 会话 ID，用于校验用户登录状态，必填，不存在则跳转至登录页             |
| `orderId`        | String   | 请求参数（GET）| 订单号，用于 “确认收货” 操作，必填，需与数据库中`orders.order_id`匹配 |

#### （5）输出说明
| 输出内容         | 数据类型   | 去向         | 说明                                                               |
|------------------|------------|--------------|----------------------------------------------------------------------|
| `model.Session`对象 | 结构体     | 模板渲染     | 包含订单列表（`Orders`）、用户信息（`UserName`）、登录状态（`IsLogin`） |
| 订单状态文本     | 字符串     | 页面展示     | 如 “未发货”“已发货”“已收货”，根据`Order.State`转换                   |
| 操作提示         | 字符串     | 页面弹窗 / 文本 | 如 “确认收货成功”“请先登录查看订单”                                   |

#### （6）算法
- **订单状态转换算法**：  
  数据库中`orders.state`字段存储状态码（0 - 未发货 / 1 - 已发货 / 2 - 已收货）；  
  前端模板通过条件判断转换为文本：`{{if eq .State 0}}未发货{{else if eq .State 1}}已发货{{else}}已收货{{end}}`。

- **订单查询排序算法**：  
  DAO 层查询时添加`ORDER BY create_time DESC`，确保最新创建的订单排在最前；  
  无需额外分页（当前逻辑未实现分页，所有订单一次性加载）。

#### （7）流程逻辑
1. **个人订单查询流程**：  
   ① 用户访问`/getMyOrders`，请求携带`userCookie`（会话 ID）；  
   ② `GetMyOrders`调用`dao.IsLogin`校验登录状态：
  - 未登录：跳转至登录页；
  - 已登录：获取用户 ID，调用`dao.GetMyOrders`查询该用户的所有订单；  
    ③ 将订单列表设置到`Session`对象，渲染`views/pages/order/order.html`，展示订单信息。

2. **确认收货流程**：  
   ① 用户点击 “确认收货” 按钮，请求携带`orderId`参数；  
   ② `TakeOrder`解析`orderId`，调用`dao.UpdateOrderState`将状态更新为 2；  
   ③ 重新调用`GetMyOrders`函数，刷新订单列表，显示更新后的状态。

#### （8）接口
| 接口类型   | 接口名称 / 路径       | 功能描述                                               | 参数说明                                                     |
|------------|-----------------------|--------------------------------------------------------|--------------------------------------------------------------|
| 路由接口   | `/getMyOrders`        | 获取当前用户的所有订单，映射至`GetMyOrders`函数         | 依赖`userCookie`（会话 ID），无额外参数                       |
| 路由接口   | `/takeOrder`          | 确认收货，更新订单状态，映射至`TakeOrder`函数           | 需`orderId`请求参数，依赖`userCookie`（会话 ID）             |
| DAO 接口   | `dao.GetMyOrders`     | 根据用户 ID 查询所有订单                               | 入参：`userID`（int64）；出参：`[]*model.Order`、`error`      |
| DAO 接口   | `dao.UpdateOrderState`| 更新订单状态                                           | 入参：`orderID`（String）、`state`（int）；出参：`error`      |

#### （9）存储分配
- **订单数据存储**：订单信息（订单号、创建时间、总数量、总金额、状态、用户 ID）存储于 MySQL 数据库`bookstore0612`的`orders`表，字段与`model.Order`结构体一一对应（如`order_id`对应`Order.OrderID`，`state`对应`Order.State`）。
- **会话存储**：同首页，用户登录状态通过`Session`存储于`sessions`表，关联用户 ID 用于订单查询。

#### （10）注释设计
- 路由配置注释：`main.go`中`/getMyOrders`和`/takeOrder`路由添加功能说明，如`// 获取我的订单`、`// 确认收货`。
- 控制器函数注释：`orderhandler.go`中`GetMyOrders`和`TakeOrder`函数注释包含参数处理、业务逻辑说明。
- DAO 函数注释：订单相关 DAO 函数（如`GetMyOrders`）注释说明 SQL 查询条件（`WHERE user_id = ?`）和排序逻辑。
- 模板注释：`views/pages/order/order.html`中添加订单状态渲染注释，如`<!-- 根据订单状态显示对应文本 -->`。

#### （11）限制条件
- **登录限制**：未登录用户访问`/getMyOrders`会被拦截，需先登录；
- **权限限制**：用户只能查看和操作自己的订单（通过`user_id`过滤），无法访问其他用户订单；
- **状态操作限制**：仅 “已发货”（`state=1`）的订单可执行 “确认收货” 操作，其他状态下按钮隐藏或置灰。

#### （12）测试计划
| 测试场景           | 测试用例                                                     | 预期结果                                                                 |
|--------------------|--------------------------------------------------------------|--------------------------------------------------------------------------|
| 未登录访问         | 清除 Cookie 后访问`http://localhost:8080/getMyOrders`        | 跳转至登录页，提示 “请先登录”                                             |
| 已登录查询订单     | 登录后访问`http://localhost:8080/getMyOrders`                | 显示当前用户的所有订单，按创建时间倒序排列，状态文本正确（如 “已发货”）   |
| 确认收货（有效）   | 点击 “已发货” 状态订单的 “确认收货” 按钮                     | 订单状态更新为 “已收货”，页面刷新后显示最新状态，数据库`state`字段变为 2  |
| 确认收货（无效）   | 对 “未发货” 或 “已收货” 状态的订单构造`/takeOrder?orderId=xxx`请求 | 状态无变化（后端未做额外校验，建议前端隐藏无效状态的操作按钮）             |

#### （13）尚未解决的问题
- **订单分页缺失**：当用户订单数量过多时，一次性加载所有订单会导致页面卡顿，需补充分页查询逻辑。
- **操作权限校验**：后端未严格校验订单归属（仅通过前端过滤），恶意用户可能通过构造`orderId`操作他人订单，需在`TakeOrder`中添加用户 ID 与订单用户 ID 的匹配校验。
- **状态操作提示**：确认收货后无明确成功提示，用户体验不佳，需添加弹窗提示或页面消息。
# 六、订单详情页

## （一）程序系统的结构

订单详情页用于展示单个订单所包含的所有订单项信息，基于 Go 语言`net/http`标准库构建，采用 "请求路由 - 控制器处理 - 数据访问" 三层架构。

前端通过静态资源（CSS、JS、图书封面图片）实现页面渲染，后端通过路由映射（`/getOrderInfo`）将携带订单号的用户请求分发至对应控制器函数；控制器先解析请求中的订单号参数，再调用数据访问层（DAO）接口查询该订单关联的所有订单项数据，最终将订单项列表、图书信息等数据封装后返回至前端模板，完成订单详情的可视化展示。

核心数据流向为：**用户请求（查看订单详情）→ 路由匹配（`/getOrderInfo`）→ 控制器处理（订单号解析、订单项查询）→ DAO 层操作数据库（查询`order_items`表）→ 数据封装（`OrderItem`对象列表）→ 模板渲染（`order_info.html`）→ 页面响应（展示订单项明细）**。

## （二）单元设计说明

### 1. 标识符

- 路由标识符：`/getOrderInfo`（获取订单详情的核心路由）
- 控制器函数标识符：`GetOrderInfo`（处理订单详情查询的核心函数）
- 数据模型标识符：`model.OrderItem`（订单项数据模型，存储单本图书的购买信息）、`model.Book`（关联的图书数据模型，存储图书基础信息）

### 2. 标准表述方式

#### （1）程序描述

订单详情页作为订单系统的子页面，负责接收用户对特定订单的明细查询请求，展示订单包含的每本图书的详细信息（图书名称、作者、单价、购买数量、小计金额、图书封面），以及订单总数量、总金额等汇总数据。

程序通过`GetOrderInfo`函数解析 URL 中的`orderId`参数，调用`dao.GetOrderItemsByOrderID`接口从数据库`order_items`表查询该订单对应的所有订单项；同时关联`books`表补充图书封面、作者等信息，最终将数据传递至`views/pages/order/order_info.html`模板，通过模板遍历渲染订单项列表，并实时计算展示订单总数量和总金额。

#### （2）功能

| 功能模块 | 核心逻辑 | 关联接口 / 函数 |
|----------|----------|------------------|
| 订单项查询 | 解析 URL 中的`orderId`参数，调用`dao.GetOrderItemsByOrderID`查询该订单的所有订单项，关联`books`表获取图书详情 | `GetOrderInfo`（控制器）、`dao.GetOrderItemsByOrderID`（DAO）、`model.OrderItem`/`model.Book`（数据模型） |
| 订单项可视化展示 | 前端模板遍历`OrderItem`列表，依次渲染每本图书的封面、名称、作者、单价、购买数量及小计金额 | `views/pages/order/order_info.html`（模板渲染）、`model.OrderItem`（字段：`ImgPath`/`Title`/`Author`等） |
| 订单汇总计算 | 模板初始化总数量（`$totalCount`）和总金额（`$totalAmount`），通过遍历订单项完成数量与金额的累加计算 | 前端模板逻辑、`model.OrderItem`（字段：`Count`/`Amount`） |
| 页面导航支持 | 提供"返回订单列表"按钮，点击跳转至个人订单页（`/getMyOrders`） | `views/pages/order/order_info.html`（模板链接）、`/getMyOrders`（路由） |

#### （3）性能

- **数据查询性能**：通过订单号（`order_id`）查询订单项时，使用`WHERE order_id = ?`条件精准匹配，且`order_id`为数据库索引字段，查询效率高；单订单订单项数量通常与购买图书种类一致（一般为1-10条），单次查询数据量小，无性能压力。
- **页面渲染性能**：订单项列表通过模板循环遍历渲染，逻辑简单（仅包含字段展示和基础计算），无需复杂 DOM 操作；静态资源（图书封面）通过浏览器缓存机制减少重复加载，页面加载速度快。
- **并发处理性能**：基于`net/http`的 Goroutine 并发模型，每个详情查询请求独立处理，支持多用户同时访问，互不干扰，并发能力强。

#### （4）输入说明

| 输入参数 | 数据类型 | 来源 | 说明 |
|----------|----------|------|------|
| `orderId` | String | URL 参数（GET） | 订单唯一标识，用于查询对应的订单项，必填；需与数据库`order_items`表的`order_id`字段格式匹配（如 UUID 或自增 ID） |
| `user`（Cookie） | String | 浏览器 Cookie | 会话 ID，可选；若需校验登录状态，用于确认当前用户身份（未传入则视为未登录） |

#### （5）输出说明

| 输出内容 | 数据类型 | 去向 | 说明 |
|----------|----------|------|------|
| `[]*model.OrderItem`列表 | 结构体切片 | 模板渲染 | 包含每本图书的订单项信息：`OrderID`（订单号）、`BookID`（图书 ID）、`Title`（书名）、`Author`（作者）、`Price`（单价）、`Count`（数量）、`Amount`（小计）、`ImgPath`（封面路径） |
| 订单汇总数据 | 计算值（int/float64） | 页面展示 | 总数量（`$totalCount`，所有订单项`Count`累加）、总金额（`$totalAmount`，所有订单项`Amount`累加） |
| 操作提示 | 字符串 | 页面弹窗/文本 | 如"该订单不存在""请先登录查看详情"，用于异常场景反馈 |
| 静态资源 | 图书封面图片 | 浏览器加载 | 从`views/static/img`目录读取，路径由`OrderItem.ImgPath`指定（如`/static/img/book_001.jpg`） |

#### （6）算法

- **订单汇总计算算法**：
  1. 前端模板初始化变量：`{{$totalCount := 0}}`（总数量，初始为0）、`{{$totalAmount := 0.0}}`（总金额，初始为0.0）；
  2. 遍历`OrderItem`列表，完成总数量与总金额的累加计算；
  3. 渲染变量至页面：在"订单汇总"区域展示`$totalCount`和`$totalAmount`（保留2位小数）。

- **订单项关联查询算法**：  
  DAO 层执行 SQL 时，通过`INNER JOIN`关联`order_items`表和`books`表，一次性获取订单项及关联的图书信息，避免多次查询。

#### （7）流程逻辑

订单详情查询完整流程：

1. **用户触发**：点击个人订单页中某订单的"详情"按钮，请求 URL 为`/getOrderInfo?orderId=xxx`（携带目标订单号）；
2. **路由匹配**：后端通过路由配置，将`/getOrderInfo`请求映射至`GetOrderInfo`控制器函数；
3. **参数解析**：`GetOrderInfo`从 URL 中提取`orderId`参数，判断是否为空（为空则返回"订单号不能为空"提示）；
4. **（可选）登录校验**：通过`user` Cookie 获取会话 ID，调用`dao.IsLogin`校验用户登录状态（若业务要求登录后查看，则未登录时跳转至登录页）；
5. **数据查询**：调用`dao.GetOrderItemsByOrderID(orderId)`，从数据库查询该订单的所有订单项及关联图书信息；
6. **数据判断**：若查询结果为空（无对应订单项），则渲染模板时传递"该订单不存在"提示；若有结果，则封装为`[]*model.OrderItem`列表；
7. **模板渲染**：将订单项列表、汇总数据（总数量 / 总金额）传递至`views/pages/order/order_info.html`，生成 HTML 页面；
8. **页面响应**：将渲染后的页面返回至浏览器，用户查看订单详情。

#### （8）接口

| 接口类型 | 接口名称 / 路径 | 功能描述 | 参数说明 |
|----------|-----------------|----------|----------|
| 路由接口 | `/getOrderInfo` | 接收订单详情查询请求，分发至`GetOrderInfo`函数处理 | 入参：URL 参数`orderId`（String，必填）、Cookie`user`（String，可选）；出参：渲染后的`order_info.html`页面 |
| DAO 接口 | `dao.GetOrderItemsByOrderID` | 根据订单号查询所有订单项及关联图书信息 | 入参：`orderId`（String，订单唯一标识）；出参：`[]*model.OrderItem`（订单项列表）、`error`（查询异常） |
| DAO 接口 | `dao.IsLogin` | （可选）校验用户登录状态 | 入参：`req *http.Request`（包含`user` Cookie）；出参：`isLogin bool`（是否登录）、`session *model.Session`（会话信息）、`error`（校验异常） |

#### （9）存储分配

订单项数据存储：存储于 MySQL 数据库`bookstore0612`的`order_items`表，字段与`model.OrderItem`结构体映射关系如下：

| 数据库字段名 | 结构体字段名 | 数据类型 | 说明 |
|--------------|--------------|----------|------|
| `order_id` | `OrderID` | VARCHAR(50) | 订单号（外键，关联`orders`表） |
| `book_id` | `BookID` | INT | 图书 ID（外键，关联`books`表） |
| `count` | `Count` | INT | 购买数量 |
| `amount` | `Amount` | DECIMAL(10,2) | 小计金额（`price * count`） |
| `create_time` | `CreateTime` | DATETIME | 订单项创建时间 |
图书信息存储：关联的图书基础信息（名称、作者、单价、封面路径）存储于`books`表，通过`book_id`与`order_items`表关联查询。
静态资源存储：图书封面图片存储于项目`views/static/img`目录，文件名与`books`表`img_path`字段一致（如`book_001.jpg`），通过`http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("views/static"))))`配置静态资源访问路由。
#### （10）注释设计
**路由配置注释**：在`main.go`的路由注册代码处添加功能说明，明确路由用途：
订单详情页：根据orderId查询订单项明细
**控制器函数注释**：在`orderhandler.go`的`GetOrderInfo`函数上方添加注释，说明函数功能、参数、返回值及处理逻辑：
GetOrderInfo 处理订单详情查询请求
参数：req *http.Request（请求对象，包含orderId参数和user Cookie），w http.ResponseWriter（响应对象，用于返回页面）
逻辑：1. 解析orderId参数；2. （可选）校验登录状态；3. 查询订单项数据；4. 渲染详情页模板
**DAO 函数注释**：在`orderdao.go`的`GetOrderItemsByOrderID`函数上方添加注释，说明 SQL 逻辑和参数含义：
GetOrderItemsByOrderID 根据订单号查询所有订单项及关联图书信息
参数：orderId（订单唯一标识）
返回值：订单项列表（包含图书名称、作者等信息）、查询错误（无错误则为nil）
SQL逻辑：INNER JOIN order_items和books表，按order_id筛选，获取订单项及图书详情
**模板注释**：在`order_info.html`的关键渲染区域添加注释，说明代码用途：
订单项列表：遍历OrderItems渲染每本图书的购买信息
单本图书订单项
订单汇总：展示总数量和总金额（通过模板变量计算）
#### （11）限制条件
- **订单号有效性限制**：仅支持查询数据库中已存在的`orderId`，若传入无效订单号（如不存在、格式错误），页面仅显示空列表或基础提示，需额外开发"订单不存在"的友好反馈。
- **权限访问限制**：当前逻辑未校验"订单归属"，任何用户可通过构造`orderId`查看他人订单详情（如访问`/getOrderInfo?orderId=他人订单号`），存在信息泄露风险，需补充"订单所属用户 ID 与当前登录用户 ID 匹配"的校验。
- **静态资源依赖限制**：图书封面图片需严格存储于`views/static/img`目录，且`books`表`img_path`字段路径需与实际文件路径一致（如`/static/img/book_001.jpg`），否则图片加载失败。
- **数据格式限制**：`orderId`需与数据库`order_items`表的`order_id`字段格式完全匹配（如大小写敏感、长度一致），格式不匹配会导致查询无结果。

#### （12）测试计划

| 测试场景 | 测试用例 | 预期结果 |
|----------|----------|----------|
| 有效订单详情查询 | 登录后访问`http://localhost:8080/getOrderInfo?orderId=20240520001`（该订单号存在） | 页面正常加载，显示该订单的所有订单项（含封面、书名、作者等），总数量 / 总金额计算正确，无报错 |
| 无效订单详情查询 | 访问`http://localhost:8080/getOrderInfo?orderId=不存在的订单号` | 页面显示"该订单不存在或已被删除"提示，无订单项列表，无控制台报错 |
| 空订单号查询 | 访问`http://localhost:8080/getOrderInfo?orderId=`（未传订单号） | 页面显示"订单号不能为空"提示，不发起数据库查询，返回至前一页或详情页空白 |
| 未登录访问详情页 | 清除浏览器 Cookie 后，访问`http://localhost:8080/getOrderInfo?orderId=有效订单号` | 若业务要求登录查看：跳转至登录页，提示"请先登录后查看订单详情"；若允许未登录查看：正常显示详情（需结合业务规则） |
| 订单项图片加载测试 | 访问包含 3 本图书的订单详情，其中 1 本图书封面路径错误（如`/static/img/error.jpg`） | 路径正确的图片正常加载，路径错误的图片显示默认占位图（如"图片缺失"图标），无页面布局错乱 |
| 总金额计算准确性测试 | 订单包含 2 本图书：A（单价 39.9 元，数量 2，小计 79.8 元）、B（单价 59 元，数量 1，小计 59 元） | 页面"总数量"显示"3 本"，"总金额"显示"138.80 元"，计算结果与实际一致 |

## 七、管理员首页
### （一）程序系统的结构
管理员首页作为后台管理系统的入口页面，基于Go语言`net/http`标准库构建，采用“请求路由-静态页面渲染”架构。前端通过静态资源（CSS、图片）实现页面布局和样式展示，后端通过路由映射（`/pages/manager/manager.html`）将管理员请求直接导向静态HTML页面，无需复杂的业务逻辑处理和数据库交互，主要用于展示管理系统入口和功能导航。
核心数据流向为：管理员访问 → 路由匹配 → 静态页面返回 → 展示管理导航界面。
### （二）单元设计说明
#### 1. 标识符
- 路由标识符：`/pages/manager/manager.html`（管理员首页静态页面路由）
- 页面元素标识符：`header`（页头）、`main`（主内容区）、`bottom`（页脚）、`logo_img`（logo图片）、`wel_word`（欢迎文字）、导航链接（`/getPageBooks`、`/getOrders`、`/main`）
#### 2. 标准表述方式
##### （1）程序描述
管理员首页程序为管理员提供后台管理系统的入口导航功能，页面包含系统logo、“后台管理系统”标题以及三个核心功能链接：“图书管理”（跳转至图书管理页）、“订单管理”（跳转至订单管理页）、“返回商城”（跳转至用户前台首页）。主内容区显示“欢迎管理员进入后台管理系统”提示文字，整体页面结构简洁，主要起导航作用。
##### （2）功能
| 功能模块         | 核心逻辑                                                                 | 关联接口/页面                                                                 |
|------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 页面布局展示     | 通过HTML和CSS实现固定布局，包含页头（logo、标题、导航链接）、主内容区（欢迎文字）、页脚（版权信息） | `views/pages/manager/manager.html`（页面模板）、`/static/css/style.css`（样式文件） |
| 功能导航跳转     | 点击导航链接，触发页面跳转至对应功能页：<br>- “图书管理”→`/getPageBooks`<br>- “订单管理”→`/getOrders`<br>- “返回商城”→`/main` | 导航链接的`href`属性直接指向对应路由                                         |
##### （3）性能
- 加载性能：页面为纯静态HTML，仅包含少量CSS和图片资源，无数据库查询和复杂逻辑处理，加载速度极快，响应时间在毫秒级。
- 并发处理：基于`net/http`的静态文件服务机制，可高效处理多管理员同时访问，无性能瓶颈。
##### （4）输入说明
无主动输入参数，页面的展示仅依赖于静态资源的正确加载。
##### （5）输出说明
| 输出内容         | 数据类型         | 去向          | 说明                                                                 |
|------------------|------------------|---------------|----------------------------------------------------------------------|
| 静态HTML页面     | HTML文档         | 浏览器渲染    | 包含完整的页面结构，包括页头、主内容区、页脚及所有导航元素             |
| CSS样式文件      | CSS代码          | 浏览器加载    | 从`/static/css/style.css`获取，用于美化页面布局和元素样式             |
| 图片资源         | 图片文件（.gif） | 浏览器加载    | 从`/static/img/logo.gif`获取系统logo图片，用于页面标识                 |
##### （6）算法
无复杂算法，仅通过HTML的`a`标签`href`属性实现页面跳转的简单逻辑。
##### （7）流程逻辑
1. **管理员首页访问流程**：  
   ① 管理员在浏览器中输入`http://localhost:8080/pages/manager/manager.html`或从其他页面跳转至该地址；  
   ② 后端路由匹配到`/pages/`前缀，通过`http.StripPrefix`处理后，从`views/pages`目录读取`manager/manager.html`文件；  
   ③ 浏览器加载HTML页面，并自动请求关联的CSS文件（`style.css`）和logo图片（`logo.gif`）；  
   ④ 页面渲染完成，展示包含导航链接和欢迎文字的管理员首页。
2. **导航跳转流程**：  
   ① 管理员点击“图书管理”链接；  
   ② 浏览器解析`href`属性值`/getPageBooks`，向服务器发起请求；  
   ③ 服务器路由匹配至`GetPageBooks`控制器函数，处理后返回图书管理页面；  
   ④ 其他导航链接（“订单管理”“返回商城”）跳转流程类似，分别对应`/getOrders`和`/main`路由。
##### （8）接口
| 接口类型         | 接口名称/路径          | 功能描述                                                                 | 参数说明                                                                 |
|------------------|-----------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 路由接口         | `/pages/manager/manager.html` | 管理员首页静态资源路由，用于直接返回HTML页面                             | 无参数，通过`http.Handle("/pages/", ...)`配置                          |
| 导航接口         | `/getPageBooks`       | “图书管理”链接目标路由，指向图书管理页                                   | 无参数，映射至`GetPageBooks`控制器函数                                 |
| 导航接口         | `/getOrders`          | “订单管理”链接目标路由，指向订单管理页                                   | 无参数，映射至`GetOrders`控制器函数                                    |
| 导航接口         | `/main`               | “返回商城”链接目标路由，指向用户前台首页                                 | 无参数，映射至`GetPageBooksByPrice`控制器函数                          |
##### （9）存储分配
- 页面模板存储：`manager.html`文件存储于`views/pages/manager`目录，通过`http.Handle("/pages/", ...)`配置的静态资源服务提供访问。  
- 样式文件存储：`style.css`存储于`views/static/css`目录，通过`http.Handle("/static/", ...)`配置的静态资源路由供页面加载。  
- 图片资源存储：`logo.gif`存储于`views/static/img`目录，同样通过静态资源路由加载，作为系统标识展示。
##### （10）注释设计
- 页面结构注释：`manager.html`中对主要区域（页头、主内容区、页脚）添加注释，如`<!-- 页头区域：包含logo、标题和导航链接 -->`。  
- 导航链接注释：对每个导航链接添加功能说明注释，如`<!-- 点击跳转到图书管理页面 -->`。  
- 静态资源路由注释：`main.go`中对`http.Handle("/pages/", ...)`添加注释，说明其用于处理静态页面请求。
##### （11）限制条件
- 权限限制：目前页面无权限校验，普通用户若知道该页面地址可直接访问，需补充管理员权限校验逻辑，仅允许管理员角色访问。  
- 导航依赖：导航链接的有效性依赖于对应路由的正确配置，若`/getPageBooks`等路由未正确映射，点击链接会导致404错误。
##### （12）测试计划
| 测试场景         | 测试用例                                                                 | 预期结果                                                                 |
|------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 管理员首页访问   | 访问`http://localhost:8080/pages/manager/manager.html`                   | 页面正常显示，包含logo、“后台管理系统”标题、三个导航链接和欢迎文字，样式正确 |
| 图书管理跳转     | 点击“图书管理”链接                                                       | 成功跳转至图书管理页（`/getPageBooks`），展示图书列表                     |
| 订单管理跳转     | 点击“订单管理”链接                                                       | 成功跳转至订单管理页（`/getOrders`），展示订单列表                       |
| 返回商城跳转     | 点击“返回商城”链接                                                       | 成功跳转至用户前台首页（`/main`），展示图书列表                           |
| 静态资源加载     | 检查页面源码中CSS和图片的引用路径是否正确                                 | CSS和图片加载成功，页面样式符合设计预期，无404错误                        |
##### （13）尚未解决的问题
- 权限校验缺失：普通用户可直接访问管理员首页，存在安全隐患，需在访问该页面时通过`Session`校验用户角色，非管理员则跳转至登录页或提示无权限。  
- 页面交互单一：页面仅作为导航入口，无动态交互效果（如当前位置标识），可优化为点击导航链接后高亮显示当前功能页。

## 八、登录/注册页
### （一）程序系统的结构
登录/注册页是用户身份认证和账号创建的核心页面，基于“请求路由-控制器处理-数据访问”三层架构。前端通过静态HTML页面（`login.html`、`regist.html`）提供用户交互界面，后端通过`/login`（登录处理）、`/regist`（注册处理）、`/checkUserName`（用户名验证）等路由将用户请求分发至对应控制器函数，控制器调用DAO层接口与数据库交互（查询用户、创建用户、校验用户名），最终返回处理结果（登录成功/失败、注册成功/失败、用户名是否可用）。
核心数据流向为：用户输入（账号/密码/邮箱）→ 表单提交 → 路由匹配 → 控制器处理（参数解析、数据校验、数据库操作）→ 结果响应（页面跳转/提示信息）。
### （二）单元设计说明
#### 1. 标识符
- 路由标识符：`/login`（登录处理）、`/regist`（注册处理）、`/checkUserName`（用户名验证）、`/pages/user/login.html`（登录页面）、`/pages/user/regist.html`（注册页面）
- 控制器函数标识符：`Login`（登录处理函数）、`Regist`（注册处理函数）、`CheckUserName`（用户名验证函数）、`Logout`（注销函数）
- 数据模型标识符：`model.User`（用户数据模型）、`model.Session`（用户会话模型）
#### 2. 标准表述方式
##### （1）程序描述
登录/注册页程序实现用户账号的认证和创建功能。登录页（`login.html`）接收用户输入的用户名和密码，通过`Login`函数校验：若正确则创建`Session`和关联Cookie，跳转至登录成功页；若错误则返回错误提示。注册页（`regist.html`）接收用户名、密码和邮箱，通过`CheckUserName`函数实时验证用户名是否已存在（基于Ajax），`Regist`函数将新用户信息保存至数据库，成功后跳转至注册成功页。注销功能（`Logout`函数）通过删除`Session`和Cookie实现用户退出登录。
##### （2）功能
| 功能模块         | 核心逻辑                                                                 | 关联接口/函数                                                                 |
|------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 用户登录         | 接收`username`和`password`，调用`dao.CheckUserNameAndPassword`校验，正确则创建`Session`和Cookie，错误则返回提示 | `Login`（控制器）、`dao.CheckUserNameAndPassword`（DAO）、`dao.AddSession`（DAO） |
| 用户注册         | 接收`username`、`password`、`email`，先通过`CheckUserName`验证用户名可用性，可用则调用`dao.SaveUser`保存，跳转成功页 | `Regist`（控制器）、`CheckUserName`（控制器）、`dao.SaveUser`（DAO）          |
| 用户名实时验证   | 注册页输入用户名后，通过Ajax调用`CheckUserName`，返回“可用”或“已存在”提示，用于前端实时反馈 | `CheckUserName`（控制器）、`dao.CheckUserName`（DAO）                        |
| 用户注销         | 接收请求后，删除对应`Session`，设置Cookie失效，跳转至首页                 | `Logout`（控制器）、`dao.DeleteSession`（DAO）                              |
##### （3）性能
- 验证性能：登录和注册的用户名/密码校验均为单表查询（`users`表），SQL语句简单（`SELECT`/`INSERT`），响应速度快。  
- 实时验证性能：`CheckUserName`函数通过Ajax异步调用，每次验证仅需一次数据库查询，对服务器负载影响小，不阻塞页面其他操作。  
- 并发处理：支持多用户同时登录/注册，基于`net/http`的Goroutine机制，无请求阻塞问题。
##### （4）输入说明
| 输入参数         | 数据类型 | 来源          | 说明                                                                 |
|------------------|----------|---------------|----------------------------------------------------------------------|
| `username`       | String   | 表单参数（登录/注册） | 用户名，必填，登录时需与`users`表中记录匹配，注册时需唯一               |
| `password`       | String   | 表单参数（登录/注册） | 密码，必填，登录时需与`users`表中记录匹配，注册时需符合格式要求（未做限制） |
| `email`          | String   | 表单参数（注册） | 邮箱，必填，需符合邮箱格式（未做校验）                                 |
| `user`（Cookie） | String   | 浏览器Cookie  | 会话ID，用于注销功能，标识当前登录用户的`Session`                       |
##### （5）输出说明
| 输出内容         | 数据类型         | 去向          | 说明                                                                 |
|------------------|------------------|---------------|----------------------------------------------------------------------|
| 登录结果         | 页面跳转/提示文字 | 登录页/成功页 | 成功→跳转至`login_success.html`；失败→登录页显示“用户名或密码不正确！” |
| 注册结果         | 页面跳转/提示文字 | 注册页/成功页 | 成功→跳转至`regist_success.html`；失败→注册页显示“用户名已存在！”       |
| 用户名验证结果   | 字符串/HTML片段  | 注册页Ajax回调 | 可用→返回“<font style='color:green'>用户名可用！</font>”；已存在→返回“用户名已存在！” |
| 注销结果         | 页面跳转         | 首页          | 注销后跳转至用户前台首页（`/main`），清除登录状态                       |
##### （6）算法
- 登录验证算法：  
  1. `Login`函数解析`username`和`password`；  
  2. 调用`dao.CheckUserNameAndPassword`执行`SELECT * FROM users WHERE username=? AND password=?`；  
  3. 若查询到用户（`user.ID > 0`），生成UUID作为`SessionID`，创建`Session`并保存至数据库，同时创建关联Cookie；  
  4. 若未查询到用户，返回错误提示。
- 注册验证算法：  
  1. `CheckUserName`函数解析`username`，调用`dao.CheckUserName`执行`SELECT * FROM users WHERE username=?`；  
  2. 若查询到用户（`user.ID > 0`），返回“用户名已存在！”；否则返回“用户名可用！”。  
  3. `Regist`函数在确认用户名可用后，调用`dao.SaveUser`执行`INSERT INTO users (username,password,email) VALUES (?,?,?)`。
- 注销算法：  
  1. `Logout`函数从Cookie中获取`SessionID`；  
  2. 调用`dao.DeleteSession`删除数据库中对应的`Session`记录；  
  3. 设置Cookie的`MaxAge = -1`使其失效，跳转至首页。
##### （7）流程逻辑
1. **用户登录流程**：  
   ① 用户访问`/pages/user/login.html`，输入用户名和密码并提交；  
   ② 请求提交至`/login`，`Login`函数解析参数；  
   ③ 调用`dao.CheckUserNameAndPassword`校验用户名和密码：        - 校验通过：生成`Session`和Cookie，跳转至`login_success.html`；        - 校验失败：返回登录页并显示“用户名或密码不正确！”。
2. **用户注册流程**：  
   ① 用户访问`/pages/user/regist.html`，输入用户名、密码和邮箱；  
   ② 输入用户名时，通过Ajax调用`/checkUserName`实时验证：        - 已存在：显示红色提示“用户名已存在！”；        - 可用：显示绿色提示“用户名可用！”；  
   ③ 用户提交表单，请求至`/regist`，`Regist`函数再次校验用户名；  
   ④ 用户名可用则调用`dao.SaveUser`保存，跳转至`regist_success.html`；否则返回注册页提示。
3. **用户注销流程**：  
   ① 已登录用户点击“注销”链接，请求至`/logout`；  
   ② `Logout`函数获取Cookie中的`SessionID`，删除对应`Session`；  
   ③ 设置Cookie失效，跳转至用户前台首页，登录状态清除。
##### （8）接口
| 接口类型         | 接口名称/路径          | 功能描述                                                                 | 参数说明                                                                 |
|------------------|-----------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 路由接口         | `/login`              | 登录处理，映射至`Login`函数                                              | 需表单参数：`username`、`password`                                      |
| 路由接口         | `/regist`             | 注册处理，映射至`Regist`函数                                             | 需表单参数：`username`、`password`、`email`                             |
| 路由接口         | `/checkUserName`      | 用户名验证，映射至`CheckUserName`函数                                    | 需表单参数：`username`（POST方式）                                      |
| 路由接口         | `/logout`             | 注销处理，映射至`Logout`函数                                             | 依赖`user`Cookie（`SessionID`）                                        |
| DAO接口          | `dao.CheckUserNameAndPassword` | 校验用户名和密码是否匹配                                             | 入参：`username`、`password`（String）；出参：`*model.User`、`error`     |
| DAO接口          | `dao.CheckUserName`   | 检查用户名是否已存在                                                     | 入参：`username`（String）；出参：`*model.User`、`error`                 |
| DAO接口          | `dao.SaveUser`        | 保存新用户信息                                                           | 入参：`username`、`password`、`email`（String）；出参：`error`           |
| DAO接口          | `dao.DeleteSession`   | 根据`SessionID`删除会话                                                 | 入参：`sessionID`（String）；出参：`error`                               |
##### （9）存储分配
- 页面模板存储：`login.html`和`regist.html`存储于`views/pages/user`目录，通过静态资源路由提供访问。  
- 用户数据存储：用户信息（用户名、密码、邮箱）存储于MySQL数据库`bookstore0612`的`users`表，字段与`model.User`结构体对应（`username`对应`User.Username`等）。  
- 会话存储：用户登录状态通过`Session`存储于`sessions`表，`SessionID`（UUID）通过Cookie在浏览器和服务器间传递。
##### （10）注释设计
- 控制器函数注释：`userhandler.go`中`Login`函数注释说明登录校验流程，`Regist`函数注释说明注册逻辑，`Logout`函数注释说明注销步骤。  
- DAO函数注释：`userdao.go`中`CheckUserNameAndPassword`注释说明SQL查询条件，`SaveUser`注释说明插入字段含义。  
- 页面注释：`login.html`和`regist.html`中对表单字段添加注释，如`<!-- 用户名输入框，必填 -->`；对Ajax请求添加注释，说明请求目的。
##### （11）限制条件
- 数据格式限制：登录/注册表单未做前端格式校验（如密码长度、邮箱格式），可能导致无效数据存入数据库。  
- 安全性限制：密码以明文形式存储和传输，存在安全风险，需添加加密处理（如MD5加密存储，HTTPS传输）。  
- 并发注册限制：同一用户名可能被同时注册（未加锁），需在`Regist`函数中添加事务或唯一索引确保用户名唯一。
##### （12）测试计划
| 测试场景         | 测试用例                                                                 | 预期结果                                                                 |
|------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 登录成功         | 使用正确的用户名和密码提交登录表单                                         | 跳转至`login_success.html`，Cookie中包含`user`字段，`sessions`表新增记录 |
| 登录失败         | 使用错误的用户名或密码提交登录表单                                         | 停留在登录页，显示“用户名或密码不正确！”                                 |
| 注册成功         | 使用新用户名、密码和邮箱提交注册表单                                       | 跳转至`regist_success.html`，`users`表新增对应记录                       |
| 注册失败（用户名已存在） | 使用已存在的用户名提交注册表单                                             | 停留在注册页，显示“用户名已存在！”                                       |
| 用户名实时验证（可用） | 注册页输入新用户名，触发Ajax验证                                           | 显示绿色提示“用户名可用！”                                               |
| 用户名实时验证（已存在） | 注册页输入已存在用户名，触发Ajax验证                                       | 显示“用户名已存在！”                                                     |
| 注销功能         | 已登录用户点击“注销”链接                                                   | 跳转至首页，Cookie中`user`字段失效，`sessions`表对应记录删除             |
##### （13）尚未解决的问题
- 密码安全问题：密码未加密存储，数据库泄露会导致用户信息暴露，需使用MD5、SHA256等算法加密后存储。  
- 表单校验缺失：前端未对输入格式（如邮箱必须包含@）、长度（如密码至少6位）进行校验，后端也未补充校验，易导致无效数据。  
- 登录状态保持：`Session`无过期时间，用户登录后永久有效，存在安全隐患，需添加`Session`过期清理机制（如2小时未活动自动失效）。  

## 九、结账页
### （一）程序系统的结构
结账页是用户完成购物后提交订单的核心页面，基于“请求路由-控制器处理-数据访问”三层架构。前端通过`checkout.html`模板展示订单确认信息，后端通过`/checkout`路由将用户请求分发至`Checkout`控制器函数，控制器调用DAO层接口完成订单创建、订单项生成、购物车清空、图书库存及销量更新等一系列操作，最终将订单信息返回至前端模板，完成结账流程。
核心数据流向为：用户点击结账 → 路由匹配 → 控制器处理（订单生成、库存更新、购物车清空）→ DAO层多表操作（`orders`、`order_items`、`cart_items`、`books`）→ 数据封装（订单ID）→ 模板渲染 → 展示结账成功页面。
### （二）单元设计说明
#### 1. 标识符
- 路由标识符：`/checkout`（结账处理）、`views/pages/cart/checkout.html`（结账页面模板）
- 控制器函数标识符：`Checkout`（结账处理函数）
- 数据模型标识符：`model.Order`（订单模型）、`model.OrderItem`（订单项模型）、`model.Cart`（购物车模型）、`model.Session`（会话模型）
#### 2. 标准表述方式
##### （1）程序描述
结账页程序实现用户从购物车到生成订单的完整流程。用户在购物车页面点击“结账”后，`Checkout`函数触发：首先获取用户购物车信息，生成唯一订单号（UUID）和订单创建时间；然后创建`Order`对象并保存至`orders`表；接着将购物车中的购物项转换为`OrderItem`对象，保存至`order_items`表；同时更新对应图书的销量（+购物项数量）和库存（-购物项数量）；最后清空用户购物车，将订单号存入`Session`，渲染`checkout.html`页面展示订单确认信息。
##### （2）功能
| 功能模块         | 核心逻辑                                                                 | 关联接口/函数                                                                 |
|------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 订单创建         | 生成订单号（UUID）和创建时间，封装`Order`对象（总数量、总金额、用户ID等），调用`dao.AddOrder`保存至数据库 | `Checkout`（控制器）、`utils.CreateUUID`（UUID生成）、`dao.AddOrder`（DAO） |
| 订单项生成       | 遍历购物车中的`CartItem`，转换为`OrderItem`对象（图书信息、数量、金额等），调用`dao.AddOrderItem`保存 | `Checkout`（控制器）、`dao.AddOrderItem`（DAO）                            |
| 图书信息更新     | 针对每个订单项，更新对应图书的销量（`sales += count`）和库存（`stock -= count`），调用`dao.UpdateBook`保存 | `Checkout`（控制器）、`dao.UpdateBook`（DAO）                              |
| 购物车清空       | 订单生成后，调用`dao.DeleteCartByCartID`删除用户购物车及关联购物项           | `Checkout`（控制器）、`dao.DeleteCartByCartID`（DAO）                      |
| 订单信息展示     | 将订单号存入`Session`，渲染`checkout.html`页面，展示订单号和提示信息         | `checkout.html`（模板）、`model.Session`（会话存储订单号）                  |
##### （3）性能
- 事务性能：结账流程涉及多表操作（订单、订单项、图书、购物车），需保证原子性（全部成功或全部失败），目前未使用事务，可能导致数据不一致，需添加事务控制。  
- 数据操作性能：单订单处理涉及1次订单插入、N次订单项插入（N为购物项数量）、N次图书更新、1次购物车删除，操作较多但均为单条SQL，适合小订单量场景。  
- 并发控制：高并发下可能出现库存超卖（如同时下单导致库存为负），需添加库存锁定机制（如`SELECT ... FOR UPDATE`）。
##### （4）输入说明
无显式输入参数，结账流程依赖用户已登录且购物车中有商品：
- 隐含输入：用户`Session`（通过Cookie中的`user`字段获取`SessionID`，进而获取`UserID`）、用户购物车信息（通过`UserID`从`carts`和`cart_items`表查询）。
##### （5）输出说明
| 输出内容         | 数据类型         | 去向          | 说明                                                                 |
|------------------|------------------|---------------|----------------------------------------------------------------------|
| 订单号           | String（UUID）   | `Session`/模板 | 生成的唯一订单标识，存储于`Session.OrderID`，用于`checkout.html`展示 |
| 结账页面         | HTML文档         | 浏览器渲染    | `checkout.html`页面，显示“订单提交成功！您的订单号为：xxx”             |
| 数据库更新       | 多表数据变更     | 数据库        | `orders`表新增订单、`order_items`表新增订单项、`books`表更新销量/库存、`carts`/`cart_items`表删除购物车数据 |
##### （6）算法
- 订单号生成算法：调用`utils.CreateUUID`生成全球唯一标识符（UUID），确保订单号不重复。  
- 订单信息计算算法：  
  1. 订单总数量（`TotalCount`）= 购物车总数量（`cart.TotalCount`）；  
  2. 订单总金额（`TotalAmount`）= 购物车总金额（`cart.TotalAmount`）；  
  3. 订单状态（`State`）初始化为0（未发货）。  
- 订单项转换算法：遍历购物车的`CartItems`，将每个`CartItem`的`Book`信息（标题、作者、价格等）、`Count`（数量）、`Amount`（金额）映射至`OrderItem`，关联订单号（`OrderID`）。  
- 图书更新算法：对于每个`OrderItem`，对应图书的`Sales += Count`，`Stock -= Count`。
##### （7）流程逻辑
1. **结账处理流程**：  
   ① 用户在购物车页面点击“结账”，请求至`/checkout`；     ② `Checkout`函数通过`dao.IsLogin`获取用户`Session`和`UserID`；     ③ 调用`dao.GetCartByUserID`获取用户购物车`Cart`；     ④ 生成订单号（UUID）和创建时间（`time.Now().Format`）；     ⑤ 创建`Order`对象，调用`dao.AddOrder`保存至`orders`表；     ⑥ 遍历`cart.CartItems`：        - 转换为`OrderItem`对象，调用`dao.AddOrderItem`保存至`order_items`表；        - 更新对应图书的`Sales`和`Stock`，调用`dao.UpdateBook`保存；     ⑦ 调用`dao.DeleteCartByCartID`删除购物车及购物项；     ⑧ 将订单号存入`Session.OrderID`，渲染`checkout.html`页面。
##### （8）接口
| 接口类型         | 接口名称/路径          | 功能描述                                                                 | 参数说明                                                                 |
|------------------|-----------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 路由接口         | `/checkout`           | 结账处理，映射至`Checkout`函数                                           | 无显式参数，依赖`user`Cookie（`SessionID`）获取用户信息                  |
| DAO接口          | `dao.GetCartByUserID` | 根据用户ID查询购物车信息（含购物项）                                       | 入参：`userID`（int64）；出参：`*model.Cart`、`error`                    |
| DAO接口          | `dao.AddOrder`        | 保存订单信息至`orders`表                                                 | 入参：`*model.Order`；出参：`error`                                      |
| DAO接口          | `dao.AddOrderItem`    | 保存订单项信息至`order_items`表                                           | 入参：`*model.OrderItem`；出参：`error`                                  |
| DAO接口          | `dao.UpdateBook`      | 更新图书的销量和库存                                                     | 入参：`*model.Book`（含更新后的`Sales`和`Stock`）；出参：`error`          |
| DAO接口          | `dao.DeleteCartByCartID` | 根据购物车ID删除购物车及关联购物项                                       | 入参：`cartID`（String）；出参：`error`                                  |
##### （9）存储分配
- 结账页面模板存储：`checkout.html`存储于`views/pages/cart`目录，通过模板渲染引擎加载，展示订单确认信息。  
- 订单数据存储：订单信息（订单号、创建时间、总数量、总金额、状态、用户ID）存储于`orders`表；订单项信息（数量、金额、图书信息、订单号）存储于`order_items`表，与`orders`表通过`order_id`关联。  
- 临时数据存储：订单号在结账过程中临时存储于`Session.OrderID`，用于页面展示，不长期保存。
##### （10）注释设计
- 控制器函数注释：`orderhandler.go`中`Checkout`函数注释详细说明流程步骤（获取购物车→生成订单→创建订单项→更新图书→清空购物车）。  
- DAO函数注释：`orderdao.go`中`AddOrder`/`AddOrderItem`注释说明插入表和字段含义；`bookdao.go`中`UpdateBook`注释说明更新的字段（销量和库存）。  
- 模板注释：`checkout.html`中添加注释说明订单号展示逻辑，如`<!-- 显示当前生成的订单号，从Session中获取 -->`。
##### （11）限制条件
- 登录限制：未登录用户访问`/checkout`会被拦截（依赖`dao.IsLogin`），需先登录。  
- 购物车限制：购物车为空时点击结账无意义，需在前端添加判断（购物车为空则隐藏结账按钮）。  
- 库存限制：若结账时图书库存不足（如购物车中某图书数量为5，实际库存为3），会导致库存为负，需在结账前校验库存。  
- 事务限制：目前多表操作无事务控制，若中间步骤失败（如创建订单项成功但更新图书失败），会导致数据不一致。
##### （12）测试计划
| 测试场景         | 测试用例                                                                 | 预期结果                                                                 |
|------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| 正常结账流程     | 登录→添加图书到购物车→点击“结账”                                         | 订单生成成功，`orders`表和`order_items`表新增记录，图书`sales`和`stock`更新，购物车被清空，`checkout.html`显示订单号 |
| 未登录结账       | 未登录状态下直接访问`/checkout`                                           | 被拦截（需补充逻辑），提示“请先登录”或跳转至登录页                         |
| 购物车为空结账   | 登录→购物车为空→点击“结账”（需强制触发）                                   | 前端无响应（隐藏结账按钮）或后端提示“购物车为空，无法结账”（需补充逻辑）   |
##### （13）尚未解决的问题
- 事务缺失：多表操作无事务控制，存在数据不一致风险，需使用`database/sql`的`Tx`实现事务，确保订单、订单项、图书、购物车操作的原子性。  
- 库存超卖：未校验结账时的实际库存，可能导致库存为负，需在生成订单项前查询当前库存，若不足则提示用户并终止流程。  
- 订单状态管理：结账后订单状态固定为0（未发货），但页面未提供后续操作入口（如查看订单），需关联“我的订单”功能，允许用户跟踪订单状态。  
- 异常处理：数据库操作失败（如网络中断）时，无错误提示和回滚机制，用户可能误以为订单已生成，需添加异常捕获和友好提示。

## 数据库设计

## 外部设计

## 一、标准描述方式

### （一） 数据库标识符
- 数据库名称: bookstore0612
  - 采用项目名称+日期的命名方式
  - 数据库名称简洁明了，便于识别和管理
- 数据库类型: MySQL关系型数据库
  - 使用MySQL作为数据存储引擎
  - 支持ACID事务特性
  - 采用InnoDB存储引擎（默认）
- 连接标识符: root:root@tcp(localhost:3306)/bookstore0612
  - 用户名: root
  - 密码: root
  - 协议: tcp
  - 主机地址: localhost
  - 端口: 3306
  - 数据库名: bookstore0612
- 字符集: UTF-8
  - 支持中文字符存储
  - 兼容多语言环境

### （二） 数据库状态
- 当前状态: 生产就绪状态
  - 数据库连接通过sql.Open()方法初始化
  - 连接失败时使用panic(err.Error())终止程序
  - 支持读写操作
- 维护状态: 活跃维护中
  - 数据库连接在程序启动时建立
  - 支持在线数据操作
  - 连接池自动管理连接生命周期
- 版本兼容性:
  - 基于MySQL 5.7+版本设计
  - 使用Go语言database/sql标准库
  - 兼容MySQL 8.0版本
- 错误处理状态:
  - 连接错误时程序终止运行
  - 查询错误时返回error类型
  - 支持基本的错误处理机制

## 二、使用该数据库的程序约定

### （一） 程序架构约定
- 编程语言: Go 1.18+语言环境
  - 使用Go语言进行后端开发
  - 采用Go标准库进行数据库操作
  - 支持Go语言的并发特性
- ORM框架: 原生database/sql包
  - 不使用第三方ORM框架
  - 直接使用SQL语句进行数据库操作
  - 通过结构体映射数据库表结构
- 连接管理: 单例模式
  - 使用全局变量utils.Db管理数据库连接
  - 在utils/db.go中初始化连接
  - 通过init()函数自动建立连接
- 错误处理: 统一错误处理机制
  - 所有数据库操作返回error类型
  - 使用Go语言标准的错误处理方式
  - 支持错误传播和检查

### （二） 数据访问约定
- DAO模式: Data Access Object模式
  - 在dao包中实现数据访问逻辑
  - 每个实体对应一个DAO文件
  - 分离数据访问逻辑和业务逻辑
- 模型映射: 结构体与表一一对应
  - 在model包中定义数据结构
  - 结构体字段与数据库表字段对应
  - 支持Go语言的数据类型映射
- SQL注入防护: 参数化查询
  - 使用?占位符进行参数绑定
  - 禁止字符串拼接SQL语句
  - 通过QueryRow、Exec等方法执行查询
- 查询优化: 预编译语句
  - 使用Prepare方法预编译SQL语句
  - 提高查询性能和安全性
  - 支持重复执行相同查询

### （三）业务逻辑约定
- 用户认证: 用户名密码认证
  - 通过users表存储用户信息
  - 支持用户注册和登录功能
  - 密码明文存储（教学项目）
- 会话管理: 基于数据库的会话存储
  - 使用sessions表存储会话信息
  - 通过UUID生成唯一会话ID
  - 支持会话的创建、查询和删除
- 购物车逻辑: 实时计算
  - 通过carts和cart_items表管理购物车
  - 支持购物车总价和总数量计算
  - 实现购物车的增删改查功能
- 订单处理: 状态流转管理
  - 订单状态: 0-未发货, 1-已发货, 2-交易完成
  - 支持订单的创建、查询和状态更新
  - 通过orders和order_items表管理订单
- 分页查询: LIMIT分页
  - 使用LIMIT关键字实现分页
  - 支持按价格范围查询
  - 每页显示4条记录

## 三、专门指导和支持软件

### （一）开发工具支持
- 数据库驱动: github.com/go-sql-driver/mysql
  - Go语言MySQL官方驱动
  - 支持MySQL 5.7+版本
  - 提供完整的MySQL功能支持
- 版本控制: Git版本控制系统
  - 支持代码版本管理
  - 便于团队协作开发
  - 支持分支管理和合并
- IDE支持: Go语言开发环境
  - GoLand、VS Code等IDE支持
  - 提供语法高亮和代码补全
  - 支持Go语言调试功能
- 调试工具: Go语言调试器
  - 支持断点调试
  - 提供变量查看功能
  - 支持单步执行和调用栈查看

### （二） 数据库管理工具
- 命令行工具: MySQL命令行客户端
  - 支持SQL语句执行
  - 提供数据库管理功能
  - 支持批量操作
- 图形化管理工具: MySQL Workbench
  - 提供可视化的数据库管理界面
  - 支持数据库设计和查询
  - 提供性能监控功能
- Web管理工具: phpMyAdmin
  - 基于Web的数据库管理界面
  - 支持数据库操作和查询
  - 提供用户友好的管理界面

### （三）测试和验证工具
- 单元测试: Go语言测试框架
  - 支持单元测试编写
  - 提供测试覆盖率统计
  - 支持测试自动化执行
- 数据库测试: 数据库连接测试
  - 验证数据库连接状态
  - 测试SQL语句执行
  - 检查数据完整性
- 性能测试: 基本性能监控
  - 监控数据库连接数
  - 检查查询执行时间
  - 分析数据库性能瓶颈

### （四） 部署和运维支持
- 部署环境: 本地开发环境
  - 支持Windows、Linux、macOS
  - 使用localhost进行本地开发
  - 支持Docker容器化部署
- 配置管理: 硬编码配置
  - 数据库连接信息硬编码在代码中
  - 支持环境变量配置（可扩展）
  - 便于开发环境快速部署
- 日志记录: 基本错误日志
  - 使用Go语言标准日志包
  - 记录数据库连接错误
  - 支持错误信息输出

### （五） 安全支持
- SQL注入防护: 参数化查询
  - 使用预编译语句防止SQL注入
  - 避免字符串拼接SQL语句
  - 提供基本的安全保障
- 会话安全: UUID会话管理
  - 使用UUID生成唯一会话ID
  - 设置Cookie的HttpOnly属性
  - 支持会话过期管理
- 访问控制: 基本权限控制
  - 通过Session验证用户身份
  - 支持用户登录状态检查
  - 提供基本的访问控制机制

# 结构设计

## 一、概念设计概述
基于代码分析，系统采用关系型数据库，以实体 - 关系模型描述业务对象及关系，支撑电商核心逻辑。

### （二）实体设计

#### 1.核心实体
- **用户 (User)**: ID (主键)、Username、Password、Email，为业务活动主体
- **图书 (Book)**: ID (主键)、Title、Author、Price、Sales、Stock、ImgPath，支持库存与销售管理
- **购物车 (Cart)**: CartID (主键)、TotalCount、TotalAmount、UserID (外键)，临时存储商品
- **购物项 (CartItem)**: CartItemID (主键)、Book (关联图书)、Count、Amount、CartID (外键)，组成购物车
- **订单 (Order)**: OrderID (主键)、CreateTime、TotalCount、TotalAmount、State (0 - 未发货 / 1 - 已发货 / 2 - 完成)、UserID (外键)，正式交易记录
- **订单项 (OrderItem)**: OrderItemID (主键)、Count、Amount、Title/Author/Price/ImgPath (商品快照)、OrderID (外键)，保存订单历史
- **会话 (Session)**: SessionID (主键)、UserName、UserID (外键)，维护登录状态

#### 2. 辅助实体
- **分页 (Page)**: Books、PageNo、PageSize、TotalPageNo、TotalRecord、MinPrice/MaxPrice (筛选)、IsLogin、Username
- **数据传输 (Data)**: Amount、TotalAmount、TotalCount，用于 AJAX 请求

### （三）关系设计
- **用户 - 购物车 (1:1)**: 购物车通过 UserID 关联用户，外键约束
- **用户 - 订单 (1:N)**: 订单通过 UserID 关联用户，外键约束
- **用户 - 会话 (1:N)**: 会话通过 UserID 关联用户，外键约束
- **购物车 - 购物项 (1:N)**: 购物项通过 CartID 关联购物车，外键约束
- **订单 - 订单项 (1:N)**: 订单项通过 OrderID 关联订单，外键约束
- **图书 - 购物项 (1:N)**: 购物项通过 BookID 关联图书，外键约束

### （四）业务规则
- **订单状态**: 仅从 0→1→2 流转，不回退
- **金额计算**: 购物项金额 = 数量 × 单价，购物车 / 订单总金额 = 下属项金额之和
- **分页规则**: 总页数 = 总记录数 ÷ 页大小 (向上取整)，支持价格筛选

### （五）数据完整性
- **实体完整性**: 主键非空唯一，用户名、会话 ID 等唯一
- **参照完整性**: 外键关联有效主键，支持级联清理 (如删用户清会话)
- **域完整性**: 价格用 DOUBLE (11,2)，数量为正整数，订单状态 0-2

### （六）设计特点
优势：业务逻辑清晰、关系合理、扩展性与维护性好；考虑教学友好、功能完整、技术实用、性能平衡，为后续设计奠基。

## 二、逻辑结构设计
### （一）实体关系模型

**核心实体：**
- **用户(User)**：系统使用者，拥有唯一身份标识
- **图书(Book)**：商品信息，包含基本属性和库存状态
- **会话(Session)**：用户登录状态维持
- **购物车(Cart)**：用户临时选购容器
- **订单(Order)**：交易完成的凭证
- **购物项(CartItem)**：购物车中的商品明细
- **订单项(OrderItem)**：订单中的商品明细

### 实体关系分析

**一对多关系：**
- 用户 → 会话（一个用户多个登录会话）
- 用户 → 购物车（一个用户一个购物车）
- 用户 → 订单（一个用户多个订单）
- 购物车 → 购物项（一个购物车多个商品项）
- 订单 → 订单项（一个订单多个商品项）
- 图书 → 购物项（一个图书可被多个购物车添加）

**关键业务规则：**
- 订单项冗余存储商品快照信息，确保历史数据一致性
- 购物车与用户一对一绑定，简化业务逻辑
- 会话采用UUID保证分布式环境唯一性

## 三、物理设计

### 数据库基础配置
- **数据库类型**：MySQL
- **数据库名称**：bookstore0612
- **字符编码**：UTF-8
- **存储引擎**：InnoDB